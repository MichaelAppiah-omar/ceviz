{
  "summary": {
    "totalFiles": 118,
    "analyzedFiles": 118,
    "totalIssues": 244,
    "critical": 175,
    "warnings": 69,
    "info": 0,
    "score": 0,
    "grade": "F"
  },
  "issues": [
    {
      "id": "nested-loops-167",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 167,
        "column": 29
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "matchedSuffix.unshift(...splitByCase(prefixPart).map((p) => p.toLowerCase()));",
        "context": [
          "  while (index >= 0) {",
          "    const prefixPart = prefixParts[index];",
          "    matchedSuffix.unshift(...splitByCase(prefixPart).map((p) => p.toLowerCase()));",
          "    const matchedSuffixContent = matchedSuffix.join(\"/\");",
          "    if (fileNamePartsContent === matchedSuffixContent || fileNamePartsContent.startsWith(matchedSuffixContent + \"/\") || // e.g. Item/Item/Item.vue -> Item"
        ]
      }
    },
    {
      "id": "nested-loops-260",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 260,
        "column": 25
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "scannedFiles.push(...files.map((file) => ({ relativePath: relative(dir, file), absolutePath: file })));",
        "context": [
          "  for (const dir of pagesDirs) {",
          "    const files = await resolveFiles(dir, pattern);",
          "    scannedFiles.push(...files.map((file) => ({ relativePath: relative(dir, file), absolutePath: file })));",
          "  }",
          "  scannedFiles.sort((a, b) => enUSComparator.compare(a.relativePath, b.relativePath));"
        ]
      }
    },
    {
      "id": "nested-loops-318",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 318,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (let i = 0; i < segments.length; i++) {",
        "context": [
          "      route.mode = \"client\";",
          "    }",
          "    for (let i = 0; i < segments.length; i++) {",
          "      const segment = segments[i];",
          "      const tokens = parseSegment(segment, file.absolutePath);"
        ]
      }
    },
    {
      "id": "nested-loops-321",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 321,
        "column": 10
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
        "context": [
          "      const segment = segments[i];",
          "      const tokens = parseSegment(segment, file.absolutePath);",
          "      if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
          "        continue;",
          "      }"
        ]
      }
    },
    {
      "id": "nested-loops-324",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 324,
        "column": 26
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const segmentName = tokens.map(({ value, type }) => type === SegmentTokenType.group ? \"\" : value).join(\"\");",
        "context": [
          "        continue;",
          "      }",
          "      const segmentName = tokens.map(({ value, type }) => type === SegmentTokenType.group ? \"\" : value).join(\"\");",
          "      route.name += (route.name && \"/\") + segmentName;",
          "      const routePath = getRoutePath(tokens, segments[i + 1] !== void 0 && segments[i + 1] !== \"index\");"
        ]
      }
    },
    {
      "id": "nested-loops-328",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 328,
        "column": 20
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
        "context": [
          "      const routePath = getRoutePath(tokens, segments[i + 1] !== void 0 && segments[i + 1] !== \"index\");",
          "      const path = withLeadingSlash(joinURL(route.path, routePath.replace(INDEX_PAGE_RE, \"/\")));",
          "      const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
          "      if (child && child.children) {",
          "        parent = child.children;"
        ]
      }
    },
    {
      "id": "nested-loops-399",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 399,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const macro of script.code.matchAll(PAGE_EXTRACT_RE)) {",
        "context": [
          "  for (const script of scriptBlocks) {",
          "    const found = {};",
          "    for (const macro of script.code.matchAll(PAGE_EXTRACT_RE)) {",
          "      found[macro[1]] = false;",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-420",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 420,
        "column": 10
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const error of transformed.errors) {",
        "context": [
          "        const transformed = transform(absolutePath, script.code.slice(node.start, node.end), { lang: script.loader });",
          "        if (transformed.errors.length) {",
          "          for (const error of transformed.errors) {",
          "            logger.warn(`Error while transforming \\`${fnName}()\\`` + error.codeframe);",
          "          }"
        ]
      }
    },
    {
      "id": "nested-loops-442",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 442,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const key of extractionKeys) {",
        "context": [
          "      }",
          "      if (fnName === \"definePageMeta\") {",
          "        for (const key of extractionKeys) {",
          "          const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
          "          if (!property) {"
        ]
      }
    },
    {
      "id": "nested-loops-443",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 443,
        "column": 27
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
        "context": [
          "      if (fnName === \"definePageMeta\") {",
          "        for (const key of extractionKeys) {",
          "          const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
          "          if (!property) {",
          "            continue;"
        ]
      }
    },
    {
      "id": "nested-loops-460",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 460,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const property of pageExtractArgument.properties) {",
        "context": [
          "          }",
          "        }",
          "        for (const property of pageExtractArgument.properties) {",
          "          if (property.type !== \"Property\") {",
          "            continue;"
        ]
      }
    },
    {
      "id": "nested-loops-615",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 615,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
        "context": [
          "      route.children = prepareRoutes(route.children, route, names);",
          "    }",
          "    if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
          "      delete route.name;",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-637",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 637,
        "column": 6
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const key in page.meta || {}) {",
        "context": [
          "      const metaFiltered = {};",
          "      let skipMeta = true;",
          "      for (const key in page.meta || {}) {",
          "        if (key !== DYNAMIC_META_KEY && page.meta[key] !== void 0) {",
          "          skipMeta = false;"
        ]
      }
    },
    {
      "id": "nested-loops-643",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 643,
        "column": 24
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const skipAlias = toArray(page.alias).every((val) => !val);",
        "context": [
          "        }",
          "      }",
          "      const skipAlias = toArray(page.alias).every((val) => !val);",
          "      const route = {",
          "        path: serializeRouteValue(page.path),"
        ]
      }
    },
    {
      "id": "nested-loops-652",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 652,
        "column": 6
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const key of [...defaultExtractionKeys, \"meta\"]) {",
        "context": [
          "        redirect: serializeRouteValue(page.redirect)",
          "      };",
          "      for (const key of [...defaultExtractionKeys, \"meta\"]) {",
          "        if (route[key] === void 0) {",
          "          delete route[key];"
        ]
      }
    },
    {
      "id": "nested-loops-702",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 702,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const key of [\"name\", \"path\"]) {",
        "context": [
          "      }",
          "      if (options?.overrideMeta) {",
          "        for (const key of [\"name\", \"path\"]) {",
          "          if (markedDynamic.has(key)) {",
          "            continue;"
        ]
      }
    },
    {
      "id": "nested-loops-708",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 708,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const key of [\"meta\", \"alias\", \"redirect\", \"props\"]) {",
        "context": [
          "          metaRoute[key] = route[key] ?? `${metaImportName}?.${key}`;",
          "        }",
          "        for (const key of [\"meta\", \"alias\", \"redirect\", \"props\"]) {",
          "          if (markedDynamic.has(key)) {",
          "            continue;"
        ]
      }
    },
    {
      "id": "nested-loops-903",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 903,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const name of [",
        "context": [
          "      for (const i of imports) {",
          "        const parsed = parseStaticImport(i);",
          "        for (const name of [",
          "          parsed.defaultImport,",
          "          ...Object.values(parsed.namedImports || {}),"
        ]
      }
    },
    {
      "id": "nested-loops-903",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 903,
        "column": 27
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const name of [",
        "context": [
          "      for (const i of imports) {",
          "        const parsed = parseStaticImport(i);",
          "        for (const name of [",
          "          parsed.defaultImport,",
          "          ...Object.values(parsed.namedImports || {}),"
        ]
      }
    },
    {
      "id": "nested-loops-1546",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1546,
        "column": 25
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
        "context": [
          "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
          "      for (const [key, chunk] of Object.entries(manifest)) {",
          "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
          "          delete manifest[key];",
          "          continue;"
        ]
      }
    },
    {
      "id": "nested-loops-1546",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1546,
        "column": 64
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
        "context": [
          "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
          "      for (const [key, chunk] of Object.entries(manifest)) {",
          "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
          "          delete manifest[key];",
          "          continue;"
        ]
      }
    },
    {
      "id": "nested-loops-1551",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1551,
        "column": 33
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
        "context": [
          "        }",
          "        if (chunk.isEntry) {",
          "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
          "        }",
          "      }"
        ]
      }
    },
    {
      "id": "nested-loops-2178",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2178,
        "column": 38
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
        "context": [
          "    const islands = components.filter(",
          "      (component) => component.island || // .server components without a corresponding .client component will need to be rendered as an island",
          "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
          "    );",
          "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {"
        ]
      }
    },
    {
      "id": "nested-loops-2180",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2180,
        "column": 24
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
        "context": [
          "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
          "    );",
          "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
          "      return `\"page_${p.name}\": defineAsyncComponent(${genDynamicImport(p.file)}.then(c => c.default || c))`;",
          "    }) || [];"
        ]
      }
    },
    {
      "id": "nested-loops-2208",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2208,
        "column": 10
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
        "context": [
          "    let type = `typeof ${genDynamicImport(isAbsolute(filePath) ? relative(baseDir, filePath).replace(NON_VUE_RE, \"\") : filePath.replace(NON_VUE_RE, \"\"), { wrapper: false })}['${c.export}']`;",
          "    if (c.mode === \"server\") {",
          "      if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
          "        if (c.filePath.startsWith(serverPlaceholderPath)) {",
          "          continue;"
        ]
      }
    },
    {
      "id": "nested-loops-2293",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2293,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const sibling of siblings) {",
        "context": [
          "      if (!siblings.has(directory)) {",
          "        const directoryLowerCase = directory.toLowerCase();",
          "        for (const sibling of siblings) {",
          "          if (sibling.toLowerCase() === directoryLowerCase) {",
          "            const nuxt = useNuxt();"
        ]
      }
    },
    {
      "id": "nested-loops-2304",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2304,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const _file of files) {",
        "context": [
          "      }",
          "    }",
          "    for (const _file of files) {",
          "      const filePath = join(dir.path, _file);",
          "      if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {"
        ]
      }
    },
    {
      "id": "nested-loops-2306",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2306,
        "column": 10
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
        "context": [
          "    for (const _file of files) {",
          "      const filePath = join(dir.path, _file);",
          "      if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
          "        continue;",
          "      }"
        ]
      }
    },
    {
      "id": "nested-loops-2367",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2367,
        "column": 32
      },
      "message": "Nested loop detected (O(n³) complexity)",
      "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "extreme",
        "complexity": "O(n³)",
        "estimate": "100ms → 100s+ for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
        "context": [
          "      }",
          "      const validModes = /* @__PURE__ */ new Set([\"all\", component.mode]);",
          "      const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
          "      if (existingComponent) {",
          "        const existingPriority = existingComponent.priority ?? 0;"
        ]
      }
    },
    {
      "id": "nested-loops-2565",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2565,
        "column": 75
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "(component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
        "context": [
          "      const components = options.getComponents();",
          "      const islands = components.filter(",
          "        (component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
          "      );",
          "      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href));"
        ]
      }
    },
    {
      "id": "nested-loops-2882",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2882,
        "column": 86
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
        "context": [
          "      if (!regexpMap.has(components)) {",
          "        const serverPlaceholderPath = resolve(distDir, \"app/components/server-placeholder\");",
          "        const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
          "        regexpMap.set(components, [new RegExp(`(${clientOnlyComponents.join(\"|\")})`), new RegExp(`^(${clientOnlyComponents.map((c) => `(?:(?:_unref\\\\()?(?:_component_)?(?:Lazy|lazy_)?${c}\\\\)?)`).join(\"|\")})$`), clientOnlyComponents]);",
          "      }"
        ]
      }
    },
    {
      "id": "nested-loops-3397",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3397,
        "column": 134
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
        "context": [
          "    };",
          "    const getComponents = (mode) => {",
          "      return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
          "    };",
          "    if (nuxt.options.experimental.normalizeComponentNames) {"
        ]
      }
    },
    {
      "id": "nested-loops-3418",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3418,
        "column": 27
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const extensions = (dirOptions.extensions || nuxt.options.extensions).map((e) => e.replace(STARTER_DOT_RE, \"\"));",
        "context": [
          "        const dirOptions = typeof dir === \"object\" ? dir : { path: dir };",
          "        const dirPath = resolveAlias$1(dirOptions.path);",
          "        const extensions = (dirOptions.extensions || nuxt.options.extensions).map((e) => e.replace(STARTER_DOT_RE, \"\"));",
          "        const _transpile = typeof dirOptions.transpile === \"boolean\" ? dirOptions.transpile : \"auto\";",
          "        const transpile = _transpile === \"auto\" ? dirPath.includes(\"node_modules\") : _transpile;"
        ]
      }
    },
    {
      "id": "nested-loops-3470",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3470,
        "column": 33
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
        "context": [
          "      for (const chunk of Object.values(manifest)) {",
          "        if (chunk.isEntry) {",
          "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
          "        }",
          "      }"
        ]
      }
    },
    {
      "id": "nested-loops-3493",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3493,
        "column": 44
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
        "context": [
          "          component.filePath = resolveModulePath(resolveAlias$1(component.filePath), { try: true, extensions: nuxt.options.extensions }) ?? component.filePath;",
          "        }",
          "        if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
          "          newComponents.push({",
          "            ...component,"
        ]
      }
    },
    {
      "id": "nested-loops-3502",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3502,
        "column": 65
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
        "context": [
          "          });",
          "        }",
          "        if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
          "          logger.warn(`Using server components with \\`ssr: false\\` is not supported with auto-detected component islands. If you need to use server component \\`${component.pascalName}\\`, set \\`experimental.componentIslands\\` to \\`true\\`.`);",
          "        }"
        ]
      }
    },
    {
      "id": "nested-loops-3679",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3679,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const dir of layer.config.imports?.dirs ?? []) {",
        "context": [
          "          resolve(layer.config.rootDir, layer.config.dir?.shared ?? \"shared\", \"types\")",
          "        );",
          "        for (const dir of layer.config.imports?.dirs ?? []) {",
          "          if (dir) {",
          "            composablesDirs.push(resolve(layer.config.srcDir, resolveAlias$1(dir, nuxt.options.alias)));"
        ]
      }
    },
    {
      "id": "nested-loops-3744",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3744,
        "column": 27
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
        "context": [
          "          });",
          "          for (const i of scannedImports) {",
          "            i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
          "          }",
          "          imports.push(...scannedImports);"
        ]
      }
    },
    {
      "id": "nested-loops-3848",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3848,
        "column": 20
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
        "context": [
          "  ]);",
          "  patterns.push([/(^|node_modules\\/)@vue\\/composition-api/]);",
          "  for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
          "    patterns.push([",
          "      new RegExp(`^${escapeRE(mod)}$`),"
        ]
      }
    },
    {
      "id": "nested-loops-3986",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3986,
        "column": 27
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const fallback = ast.children?.find((n) => {",
        "context": [
          "        for (const match of code.matchAll(DEVONLY_COMP_RE)) {",
          "          const ast = parse(match[0]).children[0];",
          "          const fallback = ast.children?.find((n) => {",
          "            if (n.name !== \"template\") {",
          "              return false;"
        ]
      }
    },
    {
      "id": "nested-loops-4094",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4094,
        "column": 9
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!transpile.some((t) => t.test(path))) {",
        "context": [
          "    }",
          "    const path = normalizeModuleTranspilePath(mod);",
          "    if (!transpile.some((t) => t.test(path))) {",
          "      nuxt.options.build.transpile.push(path);",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-4329",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4329,
        "column": 10
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
        "context": [
          "    }",
          "    if (propertyKey === \"dependsOn\" && property.value.type === \"ArrayExpression\") {",
          "      if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
          "        throw new Error(\"dependsOn must take an array of string literals\");",
          "      }"
        ]
      }
    },
    {
      "id": "nested-loops-4332",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4332,
        "column": 26
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "meta[propertyKey] = property.value.elements.map((e) => e.value);",
        "context": [
          "        throw new Error(\"dependsOn must take an array of string literals\");",
          "      }",
          "      meta[propertyKey] = property.value.elements.map((e) => e.value);",
          "    }",
          "  }"
        ]
      }
    },
    {
      "id": "nested-loops-4385",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4385,
        "column": 12
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const [propertyIndex, property] of arg.properties.entries()) {",
        "context": [
          "              continue;",
          "            }",
          "            for (const [propertyIndex, property] of arg.properties.entries()) {",
          "              if (property.type === \"SpreadElement\" || !(\"name\" in property.key)) {",
          "                continue;"
        ]
      }
    },
    {
      "id": "nested-loops-4560",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4560,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const name in namedImports) {",
        "context": [
          "    }",
          "    const { namedImports = {}, defaultImport, namespacedImport } = parseStaticImport(i);",
          "    for (const name in namedImports) {",
          "      addName(namedImports[name], i.specifier);",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-4911",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4911,
        "column": 6
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const ext of extensions) {",
        "context": [
          "  const resolveWithExt = (id) => {",
          "    for (const suffix of [\"\", \".\" + options.mode]) {",
          "      for (const ext of extensions) {",
          "        const rId = id + suffix + ext;",
          "        if (rId in nuxt.vfs) {"
        ]
      }
    },
    {
      "id": "nested-loops-5063",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5063,
        "column": 23
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const config of nuxt.options._layers.map((layer) => layer.config).reverse()) {",
        "context": [
          "async function initNuxt(nuxt) {",
          "  const layerDirs = getLayerDirectories(nuxt);",
          "  for (const config of nuxt.options._layers.map((layer) => layer.config).reverse()) {",
          "    if (config.hooks) {",
          "      nuxt.hooks.addHooks(config.hooks);"
        ]
      }
    },
    {
      "id": "nested-loops-5275",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5275,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
        "context": [
          "      continue;",
          "    }",
          "    if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
          "      nuxt.options.modulesDir.push(join(dirs.root, \"node_modules\"));",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-5460",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5460,
        "column": 6
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const p of layerRelativePaths) {",
        "context": [
          "        continue;",
          "      }",
          "      for (const p of layerRelativePaths) {",
          "        if (pattern.test(p)) {",
          "          return nuxt.callHook(\"restart\");"
        ]
      }
    },
    {
      "id": "nested-loops-5611",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5611,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "while (segments.length) {",
        "context": [
          "    const key = segments.pop();",
          "    let parent = options;",
          "    while (segments.length) {",
          "      const key2 = segments.shift();",
          "      parent = parent[key2] ||= {};"
        ]
      }
    },
    {
      "id": "nested-loops-5635",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5635,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const module of definedModules) {",
        "context": [
          "  for (const config of configs) {",
          "    const definedModules = config.modules ?? [];",
          "    for (const module of definedModules) {",
          "      const resolvedModule = resolveModuleWithOptions(module, nuxt);",
          "      if (resolvedModule && (!resolvedModule.resolvedPath || !resolvedModulePaths.has(resolvedModule.resolvedPath))) {"
        ]
      }
    },
    {
      "id": "nested-loops-5650",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5650,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const module of layerModules) {",
        "context": [
          "      `*/index{${nuxt.options.extensions.join(\",\")}}`",
          "    ]);",
          "    for (const module of layerModules) {",
          "      paths.add(module);",
          "      if (!modules.has(module)) {"
        ]
      }
    },
    {
      "id": "nested-loops-5658",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5658,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const module of nuxt.options[key]) {",
        "context": [
          "  }",
          "  for (const key of [\"modules\", \"_modules\"]) {",
          "    for (const module of nuxt.options[key]) {",
          "      const resolvedModule = resolveModuleWithOptions(module, nuxt);",
          "      if (resolvedModule && !modules.has(resolvedModule.module) && (!resolvedModule.resolvedPath || !resolvedModulePaths.has(resolvedModule.resolvedPath))) {"
        ]
      }
    },
    {
      "id": "nested-loops-5938",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5938,
        "column": 166
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "modules.length > 0 && options.unresolved ? `    modules?: (undefined | null | false | NuxtModule<any> | string | [NuxtModule | string, Record<string, any>] | ${modules.map(([configKey, importName, mod]) => `[${genString(mod.meta?.rawPath || importName)}, Exclude<NuxtConfig[${configKey}], boolean>]`).join(\" | \")})[],` : \"\"",
        "context": [
          "        ];",
          "      }),",
          "      modules.length > 0 && options.unresolved ? `    modules?: (undefined | null | false | NuxtModule<any> | string | [NuxtModule | string, Record<string, any>] | ${modules.map(([configKey, importName, mod]) => `[${genString(mod.meta?.rawPath || importName)}, Exclude<NuxtConfig[${configKey}], boolean>]`).join(\" | \")})[],` : \"\"",
          "    ].filter(Boolean);",
          "    const moduleDependencies = modules.flatMap(([_configKey, importName]) => ["
        ]
      }
    },
    {
      "id": "nested-loops-6149",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6149,
        "column": 284
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const shouldEnableComponentIslands = ctx.nuxt.options.experimental.componentIslands && (ctx.nuxt.options.dev || ctx.nuxt.options.experimental.componentIslands !== \"auto\" || ctx.app.pages?.some((p) => p.mode === \"server\") || ctx.app.components?.some((c) => c.mode === \"server\" && !ctx.app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")));",
        "context": [
          "      headers: void 0",
          "    };",
          "    const shouldEnableComponentIslands = ctx.nuxt.options.experimental.componentIslands && (ctx.nuxt.options.dev || ctx.nuxt.options.experimental.componentIslands !== \"auto\" || ctx.app.pages?.some((p) => p.mode === \"server\") || ctx.app.components?.some((c) => c.mode === \"server\" && !ctx.app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")));",
          "    return [",
          "      ...Object.entries(ctx.nuxt.options.app).map(([k, v]) => `export const ${camelCase(\"app-\" + k)} = ${JSON.stringify(v)}`),"
        ]
      }
    },
    {
      "id": "nested-loops-6192",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6192,
        "column": 12
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
        "context": [
          "      if (TYPE_FILENAME_RE.test(file.filename)) {",
          "        const typeFilenames = /* @__PURE__ */ new Set([file.filename.replace(TYPE_FILENAME_RE, \".d.$1ts\"), file.filename.replace(TYPE_FILENAME_RE, \".d.ts\")]);",
          "        if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
          "          continue;",
          "        }"
        ]
      }
    },
    {
      "id": "nested-loops-6255",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6255,
        "column": 27
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (options.filter && !options.filter(template)) {",
        "context": [
          "  };",
          "  for (const template of app.templates) {",
          "    if (options.filter && !options.filter(template)) {",
          "      continue;",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-6333",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6333,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const file of layoutFiles) {",
        "context": [
          "  for (const dirs of layerDirs) {",
          "    const layoutFiles = await resolveFiles(dirs.appLayouts, `**/*{${extensionGlob}}`);",
          "    for (const file of layoutFiles) {",
          "      const name = getNameFromPath(file, dirs.appLayouts);",
          "      if (!name) {"
        ]
      }
    },
    {
      "id": "nested-loops-6348",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6348,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const file of middlewareFiles) {",
        "context": [
          "      `*/index{${extensionGlob}}`",
          "    ]);",
          "    for (const file of middlewareFiles) {",
          "      const name = getNameFromPath(file);",
          "      if (!name) {"
        ]
      }
    },
    {
      "id": "nested-loops-6362",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6362,
        "column": 20
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "plugins.push(...[",
        "context": [
          "    const config = reversedLayers[i].config;",
          "    const dirs = reversedLayerDirs[i];",
          "    plugins.push(...[",
          "      ...config.plugins || [],",
          "      ...await resolveFiles(dirs.appPlugins, ["
        ]
      }
    },
    {
      "id": "nested-loops-6372",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6372,
        "column": 9
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!plugins.some((p2) => p2.src === plugin.src)) {",
        "context": [
          "  for (const p of [...nuxt.options.plugins].reverse()) {",
          "    const plugin = normalizePlugin(p);",
          "    if (!plugins.some((p2) => p2.src === plugin.src)) {",
          "      plugins.unshift(plugin);",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-6433",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6433,
        "column": 28
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
        "context": [
          "  const pluginNames = new Set(_plugins.map((plugin) => plugin.name));",
          "  for (const plugin of _plugins) {",
          "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
          "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
          "    }"
        ]
      }
    },
    {
      "id": "nested-loops-6434",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6434,
        "column": 62
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
        "context": [
          "  for (const plugin of _plugins) {",
          "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
          "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
          "    }",
          "    if (plugin.name) {"
        ]
      }
    },
    {
      "id": "nested-loops-6589",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6589,
        "column": 38
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const normalizeFiles = (files) => files.map((f) => ({",
        "context": [
          "      })",
          "    });",
          "    const normalizeFiles = (files) => files.map((f) => ({",
          "      name: f.name,",
          "      size: f.attrs?.size,"
        ]
      }
    },
    {
      "id": "nested-loops-6897",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6897,
        "column": 8
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const event of events) {",
        "context": [
          "          return;",
          "        }",
          "        for (const event of events) {",
          "          if (isIgnored(event.path)) {",
          "            continue;"
        ]
      }
    },
    {
      "id": "nested-loops-6955",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6955,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const w of [...pathsToWatch]) {",
        "context": [
          "    const path = opts?.parentDirectories ? join(dirname(resolve(nuxt.options.srcDir, pattern)), \"\") : resolve(nuxt.options.srcDir, pattern);",
          "    let shouldAdd = true;",
          "    for (const w of [...pathsToWatch]) {",
          "      if (w.startsWith(path)) {",
          "        pathsToWatch.delete(w);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-153",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 153,
        "column": 19
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const segments = resolveComponentNameSegments(fileName.toLowerCase() === \"index\" ? \"\" : fileName, prefixParts).filter(Boolean);",
        "context": [
          "  const prefixParts = splitByCase(dirname(relativePath));",
          "  const fileName = basename(relativePath, extname(relativePath));",
          "  const segments = resolveComponentNameSegments(fileName.toLowerCase() === \"index\" ? \"\" : fileName, prefixParts).filter(Boolean);",
          "  return kebabCase(segments).replace(QUOTE_RE, \"\");",
          "}"
        ]
      }
    },
    {
      "id": "array-find-in-loop-321",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 321,
        "column": 10
      },
      "message": "Array.every() inside loop creates O(n*m) complexity",
      "description": "Using every() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.every(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
        "context": [
          "      const segment = segments[i];",
          "      const tokens = parseSegment(segment, file.absolutePath);",
          "      if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
          "        continue;",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-328",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 328,
        "column": 20
      },
      "message": "Array.find() inside loop creates O(n*m) complexity",
      "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
        "context": [
          "      const routePath = getRoutePath(tokens, segments[i + 1] !== void 0 && segments[i + 1] !== \"index\");",
          "      const path = withLeadingSlash(joinURL(route.path, routePath.replace(INDEX_PAGE_RE, \"/\")));",
          "      const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
          "      if (child && child.children) {",
          "        parent = child.children;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-443",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 443,
        "column": 27
      },
      "message": "Array.find() inside loop creates O(n*m) complexity",
      "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
        "context": [
          "      if (fnName === \"definePageMeta\") {",
          "        for (const key of extractionKeys) {",
          "          const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
          "          if (!property) {",
          "            continue;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-615",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 615,
        "column": 8
      },
      "message": "Array.find() inside loop creates O(n*m) complexity",
      "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
        "context": [
          "      route.children = prepareRoutes(route.children, route, names);",
          "    }",
          "    if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
          "      delete route.name;",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-643",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 643,
        "column": 24
      },
      "message": "Array.every() inside loop creates O(n*m) complexity",
      "description": "Using every() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.every(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const skipAlias = toArray(page.alias).every((val) => !val);",
        "context": [
          "        }",
          "      }",
          "      const skipAlias = toArray(page.alias).every((val) => !val);",
          "      const route = {",
          "        path: serializeRouteValue(page.path),"
        ]
      }
    },
    {
      "id": "array-find-in-loop-903",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 903,
        "column": 27
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const name of [",
        "context": [
          "      for (const i of imports) {",
          "        const parsed = parseStaticImport(i);",
          "        for (const name of [",
          "          parsed.defaultImport,",
          "          ...Object.values(parsed.namedImports || {}),"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1008",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1008,
        "column": 80
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (prop.type === \"Property\" && prop.key.type === \"Identifier\" && options.extractedKeys?.includes(prop.key.name)) {",
        "context": [
          "            for (let i = 0; i < meta.properties.length; i++) {",
          "              const prop = meta.properties[i];",
          "              if (prop.type === \"Property\" && prop.key.type === \"Identifier\" && options.extractedKeys?.includes(prop.key.name)) {",
          "                const { serializable } = isSerializable(metaCode, prop.value);",
          "                if (!serializable) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1224",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1224,
        "column": 10
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (routerOptionsFiles.filter((p) => !p.optional).length > 0) {",
        "context": [
          "      }",
          "      const routerOptionsFiles = await resolveRouterOptions(nuxt, builtInRouterOptions);",
          "      if (routerOptionsFiles.filter((p) => !p.optional).length > 0) {",
          "        return true;",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1372",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1372,
        "column": 33
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!options2?.filter || options2.filter({ filename: \"routes.mjs\" })) {",
        "context": [
          "      }",
          "      nuxt.hook(\"app:templatesGenerated\", async (_app, _templates, options2) => {",
          "        if (!options2?.filter || options2.filter({ filename: \"routes.mjs\" })) {",
          "          await context.scanPages();",
          "        }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1435",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1435,
        "column": 12
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (page.path.includes(\":\")) {",
        "context": [
          "          prerenderRoutes.add(currentPath);",
          "        }",
          "        if (page.path.includes(\":\")) {",
          "          continue;",
          "        }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1507",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1507,
        "column": 14
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (resolvedRoutes.includes(path)) {",
        "context": [
          "          }",
          "          resolvedRoutes ||= routes.flatMap((route) => resolveRoutePaths(route));",
          "          if (resolvedRoutes.includes(path)) {",
          "            continue;",
          "          }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1537",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1537,
        "column": 34
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const getSources = (pages) => pages.filter((p) => Boolean(p.file)).flatMap(",
        "context": [
          "    }",
          "    addPlugin(resolve(runtimeDir, \"plugins/router\"));",
          "    const getSources = (pages) => pages.filter((p) => Boolean(p.file)).flatMap(",
          "      (p) => [relative(nuxt.options.srcDir, p.file), ...p.children?.length ? getSources(p.children) : []]",
          "    );"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1546",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1546,
        "column": 25
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
        "context": [
          "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
          "      for (const [key, chunk] of Object.entries(manifest)) {",
          "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
          "          delete manifest[key];",
          "          continue;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1546",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1546,
        "column": 64
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
        "context": [
          "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
          "      for (const [key, chunk] of Object.entries(manifest)) {",
          "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
          "          delete manifest[key];",
          "          continue;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1551",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1551,
        "column": 33
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
        "context": [
          "        }",
          "        if (chunk.isEntry) {",
          "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
          "        }",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1551",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1551,
        "column": 70
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
        "context": [
          "        }",
          "        if (chunk.isEntry) {",
          "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
          "        }",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1607",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1607,
        "column": 32
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
        "context": [
          "      filename: \"types/middleware.d.ts\",",
          "      getContents: ({ app }) => {",
          "        const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
          "        return [",
          "          \"import type { NavigationGuard } from 'vue-router'\","
        ]
      }
    },
    {
      "id": "array-find-in-loop-1622",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1622,
        "column": 32
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
        "context": [
          "      filename: \"types/nitro-middleware.d.ts\",",
          "      getContents: ({ app }) => {",
          "        const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
          "        return [",
          "          `export type MiddlewareKey = ${namedMiddleware.map((mw) => genString(mw.name)).join(\" | \") || \"never\"}`,"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1744",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1744,
        "column": 34
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
        "context": [
          "          }",
          "        });",
          "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        if (importsFromUnhead.length) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1744",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1744,
        "column": 69
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
        "context": [
          "          }",
          "        });",
          "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        if (importsFromUnhead.length) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1745",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1745,
        "column": 32
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
        "context": [
          "        });",
          "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        if (importsFromUnhead.length) {",
          "          if (!normalize(id).includes(\"node_modules\")) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-1745",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1745,
        "column": 68
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
        "context": [
          "        });",
          "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
          "        if (importsFromUnhead.length) {",
          "          if (!normalize(id).includes(\"node_modules\")) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2108",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2108,
        "column": 9
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return [",
        "context": [
          "const createImportMagicComments = (options) => {",
          "  const { chunkName, prefetch, preload } = options;",
          "  return [",
          "    `webpackChunkName: \"${chunkName}\"`,",
          "    prefetch === true || typeof prefetch === \"number\" ? `webpackPrefetch: ${prefetch}` : false,"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2176",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2176,
        "column": 20
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const islands = components.filter(",
        "context": [
          "    const components = app.components;",
          "    const pages = app.pages;",
          "    const islands = components.filter(",
          "      (component) => component.island || // .server components without a corresponding .client component will need to be rendered as an island",
          "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2178",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2178,
        "column": 38
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
        "context": [
          "    const islands = components.filter(",
          "      (component) => component.island || // .server components without a corresponding .client component will need to be rendered as an island",
          "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
          "    );",
          "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2180",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2180,
        "column": 24
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
        "context": [
          "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
          "    );",
          "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
          "      return `\"page_${p.name}\": defineAsyncComponent(${genDynamicImport(p.file)}.then(c => c.default || c))`;",
          "    }) || [];"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2208",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2208,
        "column": 10
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
        "context": [
          "    let type = `typeof ${genDynamicImport(isAbsolute(filePath) ? relative(baseDir, filePath).replace(NON_VUE_RE, \"\") : filePath.replace(NON_VUE_RE, \"\"), { wrapper: false })}['${c.export}']`;",
          "    if (c.mode === \"server\") {",
          "      if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
          "        if (c.filePath.startsWith(serverPlaceholderPath)) {",
          "          continue;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2306",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2306,
        "column": 10
      },
      "message": "Array.find() inside loop creates O(n*m) complexity",
      "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
        "context": [
          "    for (const _file of files) {",
          "      const filePath = join(dir.path, _file);",
          "      if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
          "        continue;",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2367",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2367,
        "column": 32
      },
      "message": "Array.find() inside loop creates O(n*m) complexity",
      "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
        "context": [
          "      }",
          "      const validModes = /* @__PURE__ */ new Set([\"all\", component.mode]);",
          "      const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
          "      if (existingComponent) {",
          "        const existingPriority = existingComponent.priority ?? 0;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2372",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2372,
        "column": 28
      },
      "message": "Array.indexOf() inside loop creates O(n*m) complexity",
      "description": "Using indexOf() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.indexOf(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "components.splice(components.indexOf(existingComponent), 1, component);",
        "context": [
          "        const newPriority = component.priority ?? 0;",
          "        if (newPriority > existingPriority) {",
          "          components.splice(components.indexOf(existingComponent), 1, component);",
          "        }",
          "        if (newPriority > 0 && newPriority === existingPriority) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2564",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2564,
        "column": 22
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const islands = components.filter(",
        "context": [
          "      }",
          "      const components = options.getComponents();",
          "      const islands = components.filter(",
          "        (component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
          "      );"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2565",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2565,
        "column": 75
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "(component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
        "context": [
          "      const components = options.getComponents();",
          "      const islands = components.filter(",
          "        (component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
          "      );",
          "      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href));"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2782",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2782,
        "column": 25
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "from: withMode([mode, \"async\"].filter(Boolean).join(\",\")),",
        "context": [
          "        {",
          "          as: \"Lazy\" + c.pascalName,",
          "          from: withMode([mode, \"async\"].filter(Boolean).join(\",\")),",
          "          name: c.export || \"default\"",
          "        }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2882",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2882,
        "column": 37
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
        "context": [
          "      if (!regexpMap.has(components)) {",
          "        const serverPlaceholderPath = resolve(distDir, \"app/components/server-placeholder\");",
          "        const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
          "        regexpMap.set(components, [new RegExp(`(${clientOnlyComponents.join(\"|\")})`), new RegExp(`^(${clientOnlyComponents.map((c) => `(?:(?:_unref\\\\()?(?:_component_)?(?:Lazy|lazy_)?${c}\\\\)?)`).join(\"|\")})$`), clientOnlyComponents]);",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2882",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2882,
        "column": 86
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
        "context": [
          "      if (!regexpMap.has(components)) {",
          "        const serverPlaceholderPath = resolve(distDir, \"app/components/server-placeholder\");",
          "        const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
          "        regexpMap.set(components, [new RegExp(`(${clientOnlyComponents.join(\"|\")})`), new RegExp(`^(${clientOnlyComponents.map((c) => `(?:(?:_unref\\\\()?(?:_component_)?(?:Lazy|lazy_)?${c}\\\\)?)`).join(\"|\")})$`), clientOnlyComponents]);",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2905",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2905,
        "column": 56
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const slotsToRemove = isClientOnlyComponent ? children.properties.filter((prop) => prop.type === \"Property\" && prop.key.type === \"Identifier\" && !PLACEHOLDER_EXACT_RE.test(prop.key.name)) : children.properties;",
        "context": [
          "          }",
          "          const isClientOnlyComponent = CLIENT_ONLY_NAME_RE.test(componentName);",
          "          const slotsToRemove = isClientOnlyComponent ? children.properties.filter((prop) => prop.type === \"Property\" && prop.key.type === \"Identifier\" && !PLACEHOLDER_EXACT_RE.test(prop.key.name)) : children.properties;",
          "          for (const slot of slotsToRemove) {",
          "            s.remove(slot.start, slot.end + 1);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2955",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2955,
        "column": 31
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const variableList = node.value.body.body.filter((statement) => statement.type === \"VariableDeclaration\");",
        "context": [
          "            removePropertyFromObject(returnStatement.argument, name, magicString);",
          "          }",
          "          const variableList = node.value.body.body.filter((statement) => statement.type === \"VariableDeclaration\");",
          "          const returnedVariableDeclaration = variableList.find((declaration) => declaration.declarations[0]?.id.type === \"Identifier\" && declaration.declarations[0]?.id.name === \"__returned__\" && declaration.declarations[0]?.init?.type === \"ObjectExpression\");",
          "          if (returnedVariableDeclaration) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-2985",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 2985,
        "column": 27
      },
      "message": "Array.findIndex() inside loop creates O(n*m) complexity",
      "description": "Using findIndex() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.findIndex(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const specifierIndex = node.specifiers.findIndex((s) => s.local.name === importName);",
        "context": [
          "      continue;",
          "    }",
          "    const specifierIndex = node.specifiers.findIndex((s) => s.local.name === importName);",
          "    if (specifierIndex > -1) {",
          "      if (node.specifiers.length > 1) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3060",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3060,
        "column": 21
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const elements = node.elements.filter((e) => e !== null && !removedNodeSet.has(e));",
        "context": [
          "    }",
          "  } else if (node.type === \"ArrayPattern\") {",
          "    const elements = node.elements.filter((e) => e !== null && !removedNodeSet.has(e));",
          "    for (const element of elements) {",
          "      const matched = findMatchingPatternToRemove(element, elements.length > 1 ? element : toRemoveIfMatched, name, removedNodeSet);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3068",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3068,
        "column": 23
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const properties = node.properties.filter((e) => e.type === \"Property\" && !removedNodeSet.has(e));",
        "context": [
          "    }",
          "  } else if (node.type === \"ObjectPattern\") {",
          "    const properties = node.properties.filter((e) => e.type === \"Property\" && !removedNodeSet.has(e));",
          "    for (const [index, property] of properties.entries()) {",
          "      let nodeToRemove = property;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3379",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3379,
        "column": 9
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
        "context": [
          "const SLASH_SEPARATOR_RE = /[\\\\/]/;",
          "function compareDirByPathLength({ path: pathA }, { path: pathB }) {",
          "  return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
          "}",
          "const DEFAULT_COMPONENTS_DIRS_RE = /\\/components(?:\\/(?:global|islands))?$/;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3379",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3379,
        "column": 66
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
        "context": [
          "const SLASH_SEPARATOR_RE = /[\\\\/]/;",
          "function compareDirByPathLength({ path: pathA }, { path: pathB }) {",
          "  return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
          "}",
          "const DEFAULT_COMPONENTS_DIRS_RE = /\\/components(?:\\/(?:global|islands))?$/;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3397",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3397,
        "column": 38
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
        "context": [
          "    };",
          "    const getComponents = (mode) => {",
          "      return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
          "    };",
          "    if (nuxt.options.experimental.normalizeComponentNames) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3397",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3397,
        "column": 134
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
        "context": [
          "    };",
          "    const getComponents = (mode) => {",
          "      return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
          "    };",
          "    if (nuxt.options.experimental.normalizeComponentNames) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3420",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3420,
        "column": 50
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const transpile = _transpile === \"auto\" ? dirPath.includes(\"node_modules\") : _transpile;",
        "context": [
          "        const extensions = (dirOptions.extensions || nuxt.options.extensions).map((e) => e.replace(STARTER_DOT_RE, \"\"));",
          "        const _transpile = typeof dirOptions.transpile === \"boolean\" ? dirOptions.transpile : \"auto\";",
          "        const transpile = _transpile === \"auto\" ? dirPath.includes(\"node_modules\") : _transpile;",
          "        if (transpile) {",
          "          nuxt.options.build.transpile.push(dirPath);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3428",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3428,
        "column": 21
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const dirs = dirPath.includes(\"node_modules\") ? libraryComponentDirs : userComponentDirs;",
        "context": [
          "          logger.warn(\"Components directory not found: `\" + dirPath + \"`\");",
          "        }",
          "        const dirs = dirPath.includes(\"node_modules\") ? libraryComponentDirs : userComponentDirs;",
          "        dirs.push({",
          "          global: moduleOptions.global,"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3470",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3470,
        "column": 33
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
        "context": [
          "      for (const chunk of Object.values(manifest)) {",
          "        if (chunk.isEntry) {",
          "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
          "        }",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3493",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3493,
        "column": 44
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
        "context": [
          "          component.filePath = resolveModulePath(resolveAlias$1(component.filePath), { try: true, extensions: nuxt.options.extensions }) ?? component.filePath;",
          "        }",
          "        if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
          "          newComponents.push({",
          "            ...component,"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3502",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3502,
        "column": 65
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
        "context": [
          "          });",
          "        }",
          "        if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
          "          logger.warn(`Using server components with \\`ssr: false\\` is not supported with auto-detected component islands. If you need to use server component \\`${component.pascalName}\\`, set \\`experimental.componentIslands\\` to \\`true\\`.`);",
          "        }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3744",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3744,
        "column": 27
      },
      "message": "Array.find() inside loop creates O(n*m) complexity",
      "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
        "context": [
          "          });",
          "          for (const i of scannedImports) {",
          "            i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
          "          }",
          "          imports.push(...scannedImports);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3848",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3848,
        "column": 20
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
        "context": [
          "  ]);",
          "  patterns.push([/(^|node_modules\\/)@vue\\/composition-api/]);",
          "  for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
          "    patterns.push([",
          "      new RegExp(`^${escapeRE(mod)}$`),"
        ]
      }
    },
    {
      "id": "array-find-in-loop-3986",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3986,
        "column": 27
      },
      "message": "Array.find() inside loop creates O(n*m) complexity",
      "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const fallback = ast.children?.find((n) => {",
        "context": [
          "        for (const match of code.matchAll(DEVONLY_COMP_RE)) {",
          "          const ast = parse(match[0]).children[0];",
          "          const fallback = ast.children?.find((n) => {",
          "            if (n.name !== \"template\") {",
          "              return false;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-4094",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4094,
        "column": 9
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!transpile.some((t) => t.test(path))) {",
        "context": [
          "    }",
          "    const path = normalizeModuleTranspilePath(mod);",
          "    if (!transpile.some((t) => t.test(path))) {",
          "      nuxt.options.build.transpile.push(path);",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-4329",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4329,
        "column": 10
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
        "context": [
          "    }",
          "    if (propertyKey === \"dependsOn\" && property.value.type === \"ArrayExpression\") {",
          "      if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
          "        throw new Error(\"dependsOn must take an array of string literals\");",
          "      }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5265",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5265,
        "column": 8
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (layer.root.includes(\"node_modules\")) {",
        "context": [
          "  nuxt.options.build.transpile.push(\"nuxt/app\");",
          "  for (const layer of layerDirs) {",
          "    if (layer.root.includes(\"node_modules\")) {",
          "      nuxt.options.build.transpile.push(layer.root.replace(/\\/$/, \"\"));",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5275",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5275,
        "column": 8
      },
      "message": "Array.every() inside loop creates O(n*m) complexity",
      "description": "Using every() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.every(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
        "context": [
          "      continue;",
          "    }",
          "    if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
          "      nuxt.options.modulesDir.push(join(dirs.root, \"node_modules\"));",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5387",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5387,
        "column": 21
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
        "context": [
          "  nuxt._ignore.add(resolveIgnorePatterns());",
          "  await nuxt.callHook(\"modules:done\");",
          "  nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
          "  if (nuxt.options.experimental.componentIslands) {",
          "    addComponent({"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5387",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5387,
        "column": 71
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
        "context": [
          "  nuxt._ignore.add(resolveIgnorePatterns());",
          "  await nuxt.callHook(\"modules:done\");",
          "  nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
          "  if (nuxt.options.experimental.componentIslands) {",
          "    addComponent({"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5530",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5530,
        "column": 21
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (layer.cwd && layer.cwd.includes(\"node_modules\")) {",
        "context": [
          "  const importIncludes = [];",
          "  for (const layer of options._layers) {",
          "    if (layer.cwd && layer.cwd.includes(\"node_modules\")) {",
          "      importIncludes.push(new RegExp(`(^|\\\\/)${escapeRE(layer.cwd.split(\"node_modules/\").pop())}(\\\\/|$)(?!node_modules\\\\/)`));",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5744",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5744,
        "column": 58
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const clientPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"server\"));",
        "context": [
          "  filename: \"plugins.client.mjs\",",
          "  async getContents(ctx) {",
          "    const clientPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"server\"));",
          "    checkForCircularDependencies(clientPlugins);",
          "    const exports = [];"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5763",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5763,
        "column": 58
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const serverPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"client\"));",
        "context": [
          "  filename: \"plugins.server.mjs\",",
          "  async getContents(ctx) {",
          "    const serverPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"client\"));",
          "    checkForCircularDependencies(serverPlugins);",
          "    const exports = [];"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5907",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5907,
        "column": 48
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const moduleOptionsInterface = (options) => [",
        "context": [
          "      modules.push([genString(m.meta.configKey), getImportName(m.entryPath || m.meta.name), m]);",
          "    }",
          "    const moduleOptionsInterface = (options) => [",
          "      ...modules.flatMap(([configKey, importName, mod]) => {",
          "        let link;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5987",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5987,
        "column": 29
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const globalMiddleware = app.middleware.filter((mw) => mw.global);",
        "context": [
          "  filename: \"middleware.mjs\",",
          "  getContents({ app, nuxt }) {",
          "    const globalMiddleware = app.middleware.filter((mw) => mw.global);",
          "    const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
          "    const alias = nuxt.options.dev ? { ...nuxt?.options.alias || {}, ...strippedAtAliases } : {};"
        ]
      }
    },
    {
      "id": "array-find-in-loop-5988",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5988,
        "column": 28
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
        "context": [
          "  getContents({ app, nuxt }) {",
          "    const globalMiddleware = app.middleware.filter((mw) => mw.global);",
          "    const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
          "    const alias = nuxt.options.dev ? { ...nuxt?.options.alias || {}, ...strippedAtAliases } : {};",
          "    return ["
        ]
      }
    },
    {
      "id": "array-find-in-loop-6098",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6098,
        "column": 11
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return [",
        "context": [
          "  filename: \"paths.mjs\",",
          "  getContents({ nuxt }) {",
          "    return [",
          "      \"import { joinRelativeURL } from 'ufo'\",",
          "      !nuxt.options.dev && \"import { useRuntimeConfig } from 'nitropack/runtime'\","
        ]
      }
    },
    {
      "id": "array-find-in-loop-6192",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6192,
        "column": 12
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
        "context": [
          "      if (TYPE_FILENAME_RE.test(file.filename)) {",
          "        const typeFilenames = /* @__PURE__ */ new Set([file.filename.replace(TYPE_FILENAME_RE, \".d.$1ts\"), file.filename.replace(TYPE_FILENAME_RE, \".d.ts\")]);",
          "        if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
          "          continue;",
          "        }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-6255",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6255,
        "column": 27
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (options.filter && !options.filter(template)) {",
        "context": [
          "  };",
          "  for (const template of app.templates) {",
          "    if (options.filter && !options.filter(template)) {",
          "      continue;",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-6372",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6372,
        "column": 9
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!plugins.some((p2) => p2.src === plugin.src)) {",
        "context": [
          "  for (const p of [...nuxt.options.plugins].reverse()) {",
          "    const plugin = normalizePlugin(p);",
          "    if (!plugins.some((p2) => p2.src === plugin.src)) {",
          "      plugins.unshift(plugin);",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-6433",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6433,
        "column": 28
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
        "context": [
          "  const pluginNames = new Set(_plugins.map((plugin) => plugin.name));",
          "  for (const plugin of _plugins) {",
          "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
          "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-6434",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6434,
        "column": 62
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
        "context": [
          "  for (const plugin of _plugins) {",
          "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
          "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
          "    }",
          "    if (plugin.name) {"
        ]
      }
    },
    {
      "id": "array-find-in-loop-6455",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6455,
        "column": 26
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const warningMessages = checkResults.filter(Boolean);",
        "context": [
          "async function checkForExternalConfigurationFiles() {",
          "  const checkResults = await Promise.all([checkViteConfig(), checkWebpackConfig(), checkNitroConfig(), checkPostCSSConfig()]);",
          "  const warningMessages = checkResults.filter(Boolean);",
          "  if (!warningMessages.length) {",
          "    return;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-6578",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6578,
        "column": 8
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (layer.cwd.includes(\"node_modules\")) {",
        "context": [
          "  let layerCtr = 0;",
          "  for (const layer of nuxt.options._layers) {",
          "    if (layer.cwd.includes(\"node_modules\")) {",
          "      continue;",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-6652",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6652,
        "column": 9
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return fileEntries.filter(Boolean);",
        "context": [
          "    }",
          "  }));",
          "  return fileEntries.filter(Boolean);",
          "}",
          "async function readFileWithMeta(dir, fileName, count = 0) {"
        ]
      }
    },
    {
      "id": "sync-file-op-346",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 346,
        "column": 64
      },
      "message": "readFileSync() blocks the event loop",
      "description": "Synchronous operations like readFileSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: readFile()",
        "example": "// Instead of:\nconst data = fs.readFileSync('file.txt')\n\n// Use:\nconst data = await fs.promises.readFile('file.txt')\n// or\nfs.readFile('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const fileContent = route.file in vfs ? vfs[route.file] : fs.readFileSync(ctx.fullyResolvedPaths?.has(route.file) ? route.file : await resolvePath(route.file), \"utf-8\");",
        "context": [
          "  for (const route of routes) {",
          "    if (route.file && !ctx.pagesToSkip?.has(route.file)) {",
          "      const fileContent = route.file in vfs ? vfs[route.file] : fs.readFileSync(ctx.fullyResolvedPaths?.has(route.file) ? route.file : await resolvePath(route.file), \"utf-8\");",
          "      const routeMeta = getRouteMeta(fileContent, route.file, ctx.extraExtractionKeys);",
          "      if (route.meta) {"
        ]
      }
    },
    {
      "id": "sync-file-op-1217",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1217,
        "column": 35
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
        "context": [
          "      delete tsConfig.compilerOptions.paths[\"#vue-router/*\"];",
          "    });",
          "    const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
          "    const userPreference = options.enabled;",
          "    const isPagesEnabled = async () => {"
        ]
      }
    },
    {
      "id": "sync-file-op-1217",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 1217,
        "column": 54
      },
      "message": "readdirSync() blocks the event loop",
      "description": "Synchronous operations like readdirSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: readdir()",
        "example": "// Instead of:\nconst data = fs.readdirSync('file.txt')\n\n// Use:\nconst data = await fs.promises.readdir('file.txt')\n// or\nfs.readdir('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
        "context": [
          "      delete tsConfig.compilerOptions.paths[\"#vue-router/*\"];",
          "    });",
          "    const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
          "    const userPreference = options.enabled;",
          "    const isPagesEnabled = async () => {"
        ]
      }
    },
    {
      "id": "sync-file-op-3372",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3372,
        "column": 11
      },
      "message": "statSync() blocks the event loop",
      "description": "Synchronous operations like statSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: stat()",
        "example": "// Instead of:\nconst data = fs.statSync('file.txt')\n\n// Use:\nconst data = await fs.promises.stat('file.txt')\n// or\nfs.stat('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return statSync(p).isDirectory();",
        "context": [
          "const isDirectory = (p) => {",
          "  try {",
          "    return statSync(p).isDirectory();",
          "  } catch {",
          "    return false;"
        ]
      }
    },
    {
      "id": "sync-file-op-3490",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3490,
        "column": 107
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!component._scanned && !(component.filePath in nuxt.vfs) && isAbsolute(component.filePath) && !existsSync(component.filePath)) {",
        "context": [
          "      await nuxt.callHook(\"components:extend\", newComponents);",
          "      for (const component of newComponents) {",
          "        if (!component._scanned && !(component.filePath in nuxt.vfs) && isAbsolute(component.filePath) && !existsSync(component.filePath)) {",
          "          component.filePath = resolveModulePath(resolveAlias$1(component.filePath), { try: true, extensions: nuxt.options.extensions }) ?? component.filePath;",
          "        }"
        ]
      }
    },
    {
      "id": "sync-file-op-3811",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 3811,
        "column": 10
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (existsSync(path) && !await isDirectory$1(path)) {",
        "context": [
          "        }) ?? path;",
          "      }",
          "      if (existsSync(path) && !await isDirectory$1(path)) {",
          "        path = path.replace(SUPPORTED_EXTENSION_RE, \"\");",
          "      }"
        ]
      }
    },
    {
      "id": "sync-file-op-4192",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 4192,
        "column": 24
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (filePath && existsSync(filePath)) {",
        "context": [
          "      for (const dirs of layerDirs) {",
          "        const filePath = await resolver.resolvePath(join(dirs.root, \"nuxt.schema\"));",
          "        if (filePath && existsSync(filePath)) {",
          "          let loadedConfig;",
          "          try {"
        ]
      }
    },
    {
      "id": "sync-file-op-5149",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5149,
        "column": 10
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (existsSync(declaration)) {",
        "context": [
          "    for (const dirs of layerDirs) {",
          "      const declaration = join(dirs.root, \"index.d.ts\");",
          "      if (existsSync(declaration)) {",
          "        opts.references.push({ path: declaration });",
          "        opts.nodeReferences.push({ path: declaration });"
        ]
      }
    },
    {
      "id": "sync-file-op-5791",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 5791,
        "column": 69
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return app.templates.some((t) => t.write && path === t.dst) || existsSync(path);",
        "context": [
          "    const pluginNames = [];",
          "    function exists(path) {",
          "      return app.templates.some((t) => t.write && path === t.dst) || existsSync(path);",
          "    }",
          "    for (const plugin of await annotatePlugins(nuxt, app.plugins)) {"
        ]
      }
    },
    {
      "id": "sync-file-op-6292",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6292,
        "column": 24
      },
      "message": "writeFileSync() blocks the event loop",
      "description": "Synchronous operations like writeFileSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: writeFile()",
        "example": "// Instead of:\nconst data = fs.writeFileSync('file.txt')\n\n// Use:\nconst data = await fs.promises.writeFile('file.txt')\n// or\nfs.writeFile('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "writes.push(() => writeFileSync(fullPath, contents, \"utf8\"));",
        "context": [
          "    if (template.modified && template.write) {",
          "      dirs.add(dirname(fullPath));",
          "      writes.push(() => writeFileSync(fullPath, contents, \"utf8\"));",
          "    }",
          "  }"
        ]
      }
    },
    {
      "id": "sync-file-op-6298",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6298,
        "column": 4
      },
      "message": "mkdirSync() blocks the event loop",
      "description": "Synchronous operations like mkdirSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: mkdir()",
        "example": "// Instead of:\nconst data = fs.mkdirSync('file.txt')\n\n// Use:\nconst data = await fs.promises.mkdir('file.txt')\n// or\nfs.mkdir('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "mkdirSync(dir, { recursive: true });",
        "context": [
          "  await Promise.allSettled(filteredTemplates.post.map(processTemplate));",
          "  for (const dir of dirs) {",
          "    mkdirSync(dir, { recursive: true });",
          "  }",
          "  for (const write of writes) {"
        ]
      }
    },
    {
      "id": "sync-file-op-6686",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6686,
        "column": 7
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!existsSync(cacheFile)) {",
        "context": [
          "}",
          "async function restoreCache(cwd, cacheFile) {",
          "  if (!existsSync(cacheFile)) {",
          "    return false;",
          "  }"
        ]
      }
    },
    {
      "id": "sync-file-op-6724",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6724,
        "column": 7
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (!existsSync(cacheDir)) {",
        "context": [
          "function getCacheDir(nuxt) {",
          "  let cacheDir = join(nuxt.options.workspaceDir, \"node_modules\");",
          "  if (!existsSync(cacheDir)) {",
          "    for (const dir of [...nuxt.options.modulesDir].sort((a, b) => a.length - b.length)) {",
          "      if (existsSync(dir)) {"
        ]
      }
    },
    {
      "id": "sync-file-op-6726",
      "rule": "sync-file-operations",
      "severity": "critical",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 6726,
        "column": 10
      },
      "message": "existsSync() blocks the event loop",
      "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
      "impact": {
        "type": "io",
        "level": "extreme",
        "blocking": true,
        "estimate": "50-200ms block"
      },
      "suggestion": {
        "fix": "Use async version: exists()",
        "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
        "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (existsSync(dir)) {",
        "context": [
          "  if (!existsSync(cacheDir)) {",
          "    for (const dir of [...nuxt.options.modulesDir].sort((a, b) => a.length - b.length)) {",
          "      if (existsSync(dir)) {",
          "        cacheDir = dir;",
          "        break;"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "4 sequential await calls create waterfall",
      "description": "These 4 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "4x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "13 sequential await calls create waterfall",
      "description": "These 13 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "13x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "4 sequential await calls create waterfall",
      "description": "These 4 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "4x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "4 sequential await calls create waterfall",
      "description": "These 4 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "4x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "nested-loops-153",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
        "line": 153,
        "column": 78
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
        "context": [
          "  let promiseDepth = 0;",
          "  async function executePlugin(plugin) {",
          "    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
          "    if (unresolvedPluginsForThisPlugin.length > 0) {",
          "      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-153",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
        "line": 153,
        "column": 43
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
        "context": [
          "  let promiseDepth = 0;",
          "  async function executePlugin(plugin) {",
          "    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
          "    if (unresolvedPluginsForThisPlugin.length > 0) {",
          "      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-153",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
        "line": 153,
        "column": 78
      },
      "message": "Array.some() inside loop creates O(n*m) complexity",
      "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
        "context": [
          "  let promiseDepth = 0;",
          "  async function executePlugin(plugin) {",
          "    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
          "    if (unresolvedPluginsForThisPlugin.length > 0) {",
          "      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "array-find-in-loop-13",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/head/runtime/components.js",
        "line": 13,
        "column": 4
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "Object.entries(_props).filter(([_, value]) => value !== void 0)",
        "context": [
          "const normalizeProps = (_props) => {",
          "  const props = Object.fromEntries(",
          "    Object.entries(_props).filter(([_, value]) => value !== void 0)",
          "  );",
          "  if (typeof props.body !== \"undefined\") {"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "memory-leak-interval-46",
      "rule": "memory-leak-interval",
      "severity": "critical",
      "category": "memory",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/payload.client.js",
        "line": 46,
        "column": 0
      },
      "message": "setInterval/setTimeout without cleanup causes memory leak",
      "description": "This interval/timeout is never cleared, causing a memory leak. In components, this will accumulate on every mount/unmount cycle.",
      "impact": {
        "type": "memory",
        "level": "extreme",
        "estimate": "Memory grows indefinitely, ~1-10MB per instance"
      },
      "suggestion": {
        "fix": "Clear interval/timeout in cleanup lifecycle (onUnmounted, useEffect return, etc.)",
        "example": "// React:\nuseEffect(() => {\n  const interval = setInterval(() => {...}, 1000)\n  return () => clearInterval(interval)\n}, [])",
        "docs": "https://github.com/productdevbook/ceviz#memory-leak-interval"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "setTimeout(getAppManifest, 1e3);",
        "context": [
          "      });",
          "      if (isAppManifestEnabled && navigator.connection?.effectiveType !== \"slow-2g\") {",
          "        setTimeout(getAppManifest, 1e3);",
          "      }",
          "    });"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/payload.client.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "memory-leak-interval-9",
      "rule": "memory-leak-interval",
      "severity": "critical",
      "category": "memory",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/navigation-repaint.client.js",
        "line": 9,
        "column": 0
      },
      "message": "setInterval/setTimeout without cleanup causes memory leak",
      "description": "This interval/timeout is never cleared, causing a memory leak. In components, this will accumulate on every mount/unmount cycle.",
      "impact": {
        "type": "memory",
        "level": "extreme",
        "estimate": "Memory grows indefinitely, ~1-10MB per instance"
      },
      "suggestion": {
        "fix": "Clear interval/timeout in cleanup lifecycle (onUnmounted, useEffect return, etc.)",
        "example": "// React:\nuseEffect(() => {\n  const interval = setInterval(() => {...}, 1000)\n  return () => clearInterval(interval)\n}, [])",
        "docs": "https://github.com/productdevbook/ceviz#memory-leak-interval"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "setTimeout(resolve, 100);",
        "context": [
          "    router.beforeResolve(async () => {",
          "      await new Promise((resolve) => {",
          "        setTimeout(resolve, 100);",
          "        requestAnimationFrame(() => {",
          "          setTimeout(resolve, 0);"
        ]
      }
    },
    {
      "id": "memory-leak-interval-11",
      "rule": "memory-leak-interval",
      "severity": "critical",
      "category": "memory",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/navigation-repaint.client.js",
        "line": 11,
        "column": 0
      },
      "message": "setInterval/setTimeout without cleanup causes memory leak",
      "description": "This interval/timeout is never cleared, causing a memory leak. In components, this will accumulate on every mount/unmount cycle.",
      "impact": {
        "type": "memory",
        "level": "extreme",
        "estimate": "Memory grows indefinitely, ~1-10MB per instance"
      },
      "suggestion": {
        "fix": "Clear interval/timeout in cleanup lifecycle (onUnmounted, useEffect return, etc.)",
        "example": "// React:\nuseEffect(() => {\n  const interval = setInterval(() => {...}, 1000)\n  return () => clearInterval(interval)\n}, [])",
        "docs": "https://github.com/productdevbook/ceviz#memory-leak-interval"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "setTimeout(resolve, 0);",
        "context": [
          "        setTimeout(resolve, 100);",
          "        requestAnimationFrame(() => {",
          "          setTimeout(resolve, 0);",
          "        });",
          "      });"
        ]
      }
    },
    {
      "id": "array-find-in-loop-33",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/state.js",
        "line": 33,
        "column": 64
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
        "context": [
          "  const nuxtApp = useNuxtApp();",
          "  const _allKeys = Object.keys(nuxtApp.payload.state).map((key) => key.substring(useStateKeyPrefix.length));",
          "  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
          "  for (const _key of _keys) {",
          "    const key = useStateKeyPrefix + _key;"
        ]
      }
    },
    {
      "id": "array-find-in-loop-51",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/preload.js",
        "line": 51,
        "column": 37
      },
      "message": "Array.indexOf() inside loop creates O(n*m) complexity",
      "description": "Using indexOf() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.indexOf(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "}).finally(() => promises.splice(promises.indexOf(promise)));",
        "context": [
          "    }",
          "    const promise = Promise.resolve(component()).catch(() => {",
          "    }).finally(() => promises.splice(promises.indexOf(promise)));",
          "    promises.push(promise);",
          "  }"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/payload.js",
        "line": 0,
        "column": 0
      },
      "message": "3 sequential await calls create waterfall",
      "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "3x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/payload.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/payload.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "nested-loops-94",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/fetch.js",
        "line": 94,
        "column": 4
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const [key, value] of Object.entries(obj)) {",
        "context": [
          "    }",
          "    const unwrapped = {};",
          "    for (const [key, value] of Object.entries(obj)) {",
          "      unwrapped[toValue(key)] = toValue(value);",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-272",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/asyncData.js",
        "line": 272,
        "column": 64
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
        "context": [
          "  const nuxtApp = useNuxtApp();",
          "  const _allKeys = Object.keys(nuxtApp.payload.data);",
          "  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
          "  for (const key of _keys) {",
          "    clearNuxtDataByKey(nuxtApp, key);"
        ]
      }
    },
    {
      "id": "array-find-in-loop-454",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/asyncData.js",
        "line": 454,
        "column": 15
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const list = signals.filter((s) => !!s);",
        "context": [
          "}",
          "function mergeAbortSignals(signals, timeout) {",
          "  const list = signals.filter((s) => !!s);",
          "  if (typeof timeout === \"number\" && timeout >= 0) {",
          "    const timeoutSignal = AbortSignal.timeout?.(timeout);"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-link.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-link.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "nested-loops-290",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
        "line": 290,
        "column": 37
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "{ default: () => (payloads.slots?.[slot]?.props?.length ? payloads.slots[slot].props : [{}]).map((data) => slots[slot]?.(data)) }",
        "context": [
          "                    // use different selectors for even and odd teleportKey to force trigger the teleport",
          "                    { to: import.meta.client ? `${isKeyOdd ? \"div\" : \"\"}[data-island-uid=\"${uid.value}\"][data-island-slot=\"${slot}\"]` : `uid=${uid.value};slot=${slot}` },",
          "                    { default: () => (payloads.slots?.[slot]?.props?.length ? payloads.slots[slot].props : [{}]).map((data) => slots[slot]?.(data)) }",
          "                  )",
          "                );"
        ]
      }
    },
    {
      "id": "nested-loops-301",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
        "line": 301,
        "column": 20
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const slot in slots2) {",
        "context": [
          "                    const { html: html2, slots: slots2 } = info;",
          "                    let replaced = html2.replaceAll(\"data-island-uid\", `data-island-uid=\"${uid.value}\"`);",
          "                    for (const slot in slots2) {",
          "                      replaced = replaced.replaceAll(`data-island-slot=\"${slot}\">`, (full) => full + slots2[slot]);",
          "                    }"
        ]
      }
    },
    {
      "id": "nested-loops-315",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
        "line": 315,
        "column": 70
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "return [h(component, props2, Object.fromEntries(Object.entries(slots2 || {}).map(([k, v]) => [",
        "context": [
          "                  const vnode = createVNode(Teleport, { to: `${isKeyOdd ? \"div\" : \"\"}[data-island-uid='${uid.value}'][data-island-component=\"${id2}\"]` }, {",
          "                    default: () => {",
          "                      return [h(component, props2, Object.fromEntries(Object.entries(slots2 || {}).map(([k, v]) => [",
          "                        k,",
          "                        () => createStaticVNode(`<div style=\"display: contents\" data-island-uid data-island-slot=\"${k}\">${v}</div>`, 1)"
        ]
      }
    },
    {
      "id": "array-find-in-loop-80",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
        "line": 80,
        "column": 74
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key2]) => !key2.startsWith(\"data-v-\"))) : {});",
        "context": [
          "    const config = useRuntimeConfig();",
          "    const nuxtApp = useNuxtApp();",
          "    const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key2]) => !key2.startsWith(\"data-v-\"))) : {});",
          "    const hashId = computed(() => hash([props.name, filteredProps.value, props.context, props.source]).replace(/[-_]/g, \"\"));",
          "    const instance = getCurrentInstance();"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "array-find-in-loop-54",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/client-fallback.server.js",
        "line": 54,
        "column": 26
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "await Promise.all(buffer.filter(isPromise));",
        "context": [
          "      const buffer = ssrVNodes.getBuffer();",
          "      if (buffer.hasAsync) {",
          "        await Promise.all(buffer.filter(isPromise));",
          "      }",
          "      return { ssrFailed, ssrVNodes };"
        ]
      }
    },
    {
      "id": "nested-loops-143",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
        "line": 143,
        "column": 10
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "for (const entry of toArray(componentMiddleware)) {",
        "context": [
          "            continue;",
          "          }",
          "          for (const entry of toArray(componentMiddleware)) {",
          "            middlewareEntries.add(entry);",
          "          }"
        ]
      }
    },
    {
      "id": "nested-loops-163",
      "rule": "nested-loops",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
        "line": 163,
        "column": 89
      },
      "message": "Nested loop detected (O(n²) complexity)",
      "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n²)",
        "estimate": "100ms → 10s for 1000 items"
      },
      "suggestion": {
        "fix": "Use Map/Set for O(1) lookups instead of nested loops",
        "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
        "docs": "https://github.com/productdevbook/ceviz#nested-loops"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);",
        "context": [
          "          if (!middleware) {",
          "            if (import.meta.dev) {",
          "              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);",
          "            }",
          "            throw new Error(`Unknown route middleware: '${entry}'.`);"
        ]
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "sequential-requests-0",
      "rule": "sequential-requests",
      "severity": "warning",
      "category": "io",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
        "line": 0,
        "column": 0
      },
      "message": "2 sequential await calls create waterfall",
      "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
      "impact": {
        "type": "io",
        "level": "medium",
        "estimate": "2x slower than necessary"
      },
      "suggestion": {
        "fix": "Use Promise.all() to run these operations in parallel",
        "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
        "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "",
        "context": []
      }
    },
    {
      "id": "array-find-in-loop-35",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/prerender.server.js",
        "line": 35,
        "column": 8
      },
      "message": "Array.includes() inside loop creates O(n*m) complexity",
      "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "if (route.path.includes(\":\")) {",
        "context": [
          "      routesToPrerender.add(currentPath);",
          "    }",
          "    if (route.path.includes(\":\")) {",
          "      continue;",
          "    }"
        ]
      }
    },
    {
      "id": "array-find-in-loop-30",
      "rule": "array-find-in-loop",
      "severity": "critical",
      "category": "cpu",
      "location": {
        "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/prefetch.client.js",
        "line": 30,
        "column": 19
      },
      "message": "Array.filter() inside loop creates O(n*m) complexity",
      "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
      "impact": {
        "type": "cpu",
        "level": "high",
        "complexity": "O(n*m)",
        "estimate": "10ms → 5s for 1000x1000 items"
      },
      "suggestion": {
        "fix": "Convert array to Map/Set before the loop for O(1) lookups",
        "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
        "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
      },
      "autoFixable": false,
      "codeSnippet": {
        "before": "middleware = middleware.filter((m) => typeof m === \"string\");",
        "context": [
          "      const layout = route.meta.layout;",
          "      let middleware = toArray(route.meta.middleware);",
          "      middleware = middleware.filter((m) => typeof m === \"string\");",
          "      for (const name of middleware) {",
          "        if (typeof namedMiddleware[name] === \"function\") {"
        ]
      }
    }
  ],
  "metrics": {
    "cpu": {
      "worstComplexity": "O(1)",
      "averageComplexity": "O(n)",
      "hotspots": [
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 167,
          "column": 29
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 260,
          "column": 25
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 318,
          "column": 4
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 321,
          "column": 10
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 324,
          "column": 26
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 328,
          "column": 20
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 399,
          "column": 4
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 420,
          "column": 10
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 442,
          "column": 8
        },
        {
          "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
          "line": 443,
          "column": 27
        }
      ]
    },
    "memory": {
      "estimatedBaseline": "2MB",
      "leaks": 3,
      "bloatLevel": "low"
    },
    "bundle": {
      "size": 535080,
      "potentialSavings": 0,
      "heavyDeps": []
    },
    "io": {
      "blockingOps": 14,
      "waterfalls": 69
    }
  },
  "files": [
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/schema.js",
      "size": 29,
      "lines": 2,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/kit.js",
      "size": 26,
      "lines": 2,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/config.js",
      "size": 84,
      "lines": 6,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/config.cjs",
      "size": 97,
      "lines": 8,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
      "size": 269517,
      "lines": 6971,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "nested-loops-167",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 167,
            "column": 29
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "matchedSuffix.unshift(...splitByCase(prefixPart).map((p) => p.toLowerCase()));",
            "context": [
              "  while (index >= 0) {",
              "    const prefixPart = prefixParts[index];",
              "    matchedSuffix.unshift(...splitByCase(prefixPart).map((p) => p.toLowerCase()));",
              "    const matchedSuffixContent = matchedSuffix.join(\"/\");",
              "    if (fileNamePartsContent === matchedSuffixContent || fileNamePartsContent.startsWith(matchedSuffixContent + \"/\") || // e.g. Item/Item/Item.vue -> Item"
            ]
          }
        },
        {
          "id": "nested-loops-260",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 260,
            "column": 25
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "scannedFiles.push(...files.map((file) => ({ relativePath: relative(dir, file), absolutePath: file })));",
            "context": [
              "  for (const dir of pagesDirs) {",
              "    const files = await resolveFiles(dir, pattern);",
              "    scannedFiles.push(...files.map((file) => ({ relativePath: relative(dir, file), absolutePath: file })));",
              "  }",
              "  scannedFiles.sort((a, b) => enUSComparator.compare(a.relativePath, b.relativePath));"
            ]
          }
        },
        {
          "id": "nested-loops-318",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 318,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (let i = 0; i < segments.length; i++) {",
            "context": [
              "      route.mode = \"client\";",
              "    }",
              "    for (let i = 0; i < segments.length; i++) {",
              "      const segment = segments[i];",
              "      const tokens = parseSegment(segment, file.absolutePath);"
            ]
          }
        },
        {
          "id": "nested-loops-321",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 321,
            "column": 10
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
            "context": [
              "      const segment = segments[i];",
              "      const tokens = parseSegment(segment, file.absolutePath);",
              "      if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
              "        continue;",
              "      }"
            ]
          }
        },
        {
          "id": "nested-loops-324",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 324,
            "column": 26
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const segmentName = tokens.map(({ value, type }) => type === SegmentTokenType.group ? \"\" : value).join(\"\");",
            "context": [
              "        continue;",
              "      }",
              "      const segmentName = tokens.map(({ value, type }) => type === SegmentTokenType.group ? \"\" : value).join(\"\");",
              "      route.name += (route.name && \"/\") + segmentName;",
              "      const routePath = getRoutePath(tokens, segments[i + 1] !== void 0 && segments[i + 1] !== \"index\");"
            ]
          }
        },
        {
          "id": "nested-loops-328",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 328,
            "column": 20
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
            "context": [
              "      const routePath = getRoutePath(tokens, segments[i + 1] !== void 0 && segments[i + 1] !== \"index\");",
              "      const path = withLeadingSlash(joinURL(route.path, routePath.replace(INDEX_PAGE_RE, \"/\")));",
              "      const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
              "      if (child && child.children) {",
              "        parent = child.children;"
            ]
          }
        },
        {
          "id": "nested-loops-399",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 399,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const macro of script.code.matchAll(PAGE_EXTRACT_RE)) {",
            "context": [
              "  for (const script of scriptBlocks) {",
              "    const found = {};",
              "    for (const macro of script.code.matchAll(PAGE_EXTRACT_RE)) {",
              "      found[macro[1]] = false;",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-420",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 420,
            "column": 10
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const error of transformed.errors) {",
            "context": [
              "        const transformed = transform(absolutePath, script.code.slice(node.start, node.end), { lang: script.loader });",
              "        if (transformed.errors.length) {",
              "          for (const error of transformed.errors) {",
              "            logger.warn(`Error while transforming \\`${fnName}()\\`` + error.codeframe);",
              "          }"
            ]
          }
        },
        {
          "id": "nested-loops-442",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 442,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const key of extractionKeys) {",
            "context": [
              "      }",
              "      if (fnName === \"definePageMeta\") {",
              "        for (const key of extractionKeys) {",
              "          const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
              "          if (!property) {"
            ]
          }
        },
        {
          "id": "nested-loops-443",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 443,
            "column": 27
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
            "context": [
              "      if (fnName === \"definePageMeta\") {",
              "        for (const key of extractionKeys) {",
              "          const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
              "          if (!property) {",
              "            continue;"
            ]
          }
        },
        {
          "id": "nested-loops-460",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 460,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const property of pageExtractArgument.properties) {",
            "context": [
              "          }",
              "        }",
              "        for (const property of pageExtractArgument.properties) {",
              "          if (property.type !== \"Property\") {",
              "            continue;"
            ]
          }
        },
        {
          "id": "nested-loops-615",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 615,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
            "context": [
              "      route.children = prepareRoutes(route.children, route, names);",
              "    }",
              "    if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
              "      delete route.name;",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-637",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 637,
            "column": 6
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const key in page.meta || {}) {",
            "context": [
              "      const metaFiltered = {};",
              "      let skipMeta = true;",
              "      for (const key in page.meta || {}) {",
              "        if (key !== DYNAMIC_META_KEY && page.meta[key] !== void 0) {",
              "          skipMeta = false;"
            ]
          }
        },
        {
          "id": "nested-loops-643",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 643,
            "column": 24
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const skipAlias = toArray(page.alias).every((val) => !val);",
            "context": [
              "        }",
              "      }",
              "      const skipAlias = toArray(page.alias).every((val) => !val);",
              "      const route = {",
              "        path: serializeRouteValue(page.path),"
            ]
          }
        },
        {
          "id": "nested-loops-652",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 652,
            "column": 6
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const key of [...defaultExtractionKeys, \"meta\"]) {",
            "context": [
              "        redirect: serializeRouteValue(page.redirect)",
              "      };",
              "      for (const key of [...defaultExtractionKeys, \"meta\"]) {",
              "        if (route[key] === void 0) {",
              "          delete route[key];"
            ]
          }
        },
        {
          "id": "nested-loops-702",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 702,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const key of [\"name\", \"path\"]) {",
            "context": [
              "      }",
              "      if (options?.overrideMeta) {",
              "        for (const key of [\"name\", \"path\"]) {",
              "          if (markedDynamic.has(key)) {",
              "            continue;"
            ]
          }
        },
        {
          "id": "nested-loops-708",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 708,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const key of [\"meta\", \"alias\", \"redirect\", \"props\"]) {",
            "context": [
              "          metaRoute[key] = route[key] ?? `${metaImportName}?.${key}`;",
              "        }",
              "        for (const key of [\"meta\", \"alias\", \"redirect\", \"props\"]) {",
              "          if (markedDynamic.has(key)) {",
              "            continue;"
            ]
          }
        },
        {
          "id": "nested-loops-903",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 903,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const name of [",
            "context": [
              "      for (const i of imports) {",
              "        const parsed = parseStaticImport(i);",
              "        for (const name of [",
              "          parsed.defaultImport,",
              "          ...Object.values(parsed.namedImports || {}),"
            ]
          }
        },
        {
          "id": "nested-loops-903",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 903,
            "column": 27
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const name of [",
            "context": [
              "      for (const i of imports) {",
              "        const parsed = parseStaticImport(i);",
              "        for (const name of [",
              "          parsed.defaultImport,",
              "          ...Object.values(parsed.namedImports || {}),"
            ]
          }
        },
        {
          "id": "nested-loops-1546",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1546,
            "column": 25
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
            "context": [
              "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
              "      for (const [key, chunk] of Object.entries(manifest)) {",
              "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
              "          delete manifest[key];",
              "          continue;"
            ]
          }
        },
        {
          "id": "nested-loops-1546",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1546,
            "column": 64
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
            "context": [
              "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
              "      for (const [key, chunk] of Object.entries(manifest)) {",
              "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
              "          delete manifest[key];",
              "          continue;"
            ]
          }
        },
        {
          "id": "nested-loops-1551",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1551,
            "column": 33
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
            "context": [
              "        }",
              "        if (chunk.isEntry) {",
              "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
              "        }",
              "      }"
            ]
          }
        },
        {
          "id": "nested-loops-2178",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2178,
            "column": 38
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
            "context": [
              "    const islands = components.filter(",
              "      (component) => component.island || // .server components without a corresponding .client component will need to be rendered as an island",
              "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
              "    );",
              "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {"
            ]
          }
        },
        {
          "id": "nested-loops-2180",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2180,
            "column": 24
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
            "context": [
              "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
              "    );",
              "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
              "      return `\"page_${p.name}\": defineAsyncComponent(${genDynamicImport(p.file)}.then(c => c.default || c))`;",
              "    }) || [];"
            ]
          }
        },
        {
          "id": "nested-loops-2208",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2208,
            "column": 10
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
            "context": [
              "    let type = `typeof ${genDynamicImport(isAbsolute(filePath) ? relative(baseDir, filePath).replace(NON_VUE_RE, \"\") : filePath.replace(NON_VUE_RE, \"\"), { wrapper: false })}['${c.export}']`;",
              "    if (c.mode === \"server\") {",
              "      if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
              "        if (c.filePath.startsWith(serverPlaceholderPath)) {",
              "          continue;"
            ]
          }
        },
        {
          "id": "nested-loops-2293",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2293,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const sibling of siblings) {",
            "context": [
              "      if (!siblings.has(directory)) {",
              "        const directoryLowerCase = directory.toLowerCase();",
              "        for (const sibling of siblings) {",
              "          if (sibling.toLowerCase() === directoryLowerCase) {",
              "            const nuxt = useNuxt();"
            ]
          }
        },
        {
          "id": "nested-loops-2304",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2304,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const _file of files) {",
            "context": [
              "      }",
              "    }",
              "    for (const _file of files) {",
              "      const filePath = join(dir.path, _file);",
              "      if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {"
            ]
          }
        },
        {
          "id": "nested-loops-2306",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2306,
            "column": 10
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
            "context": [
              "    for (const _file of files) {",
              "      const filePath = join(dir.path, _file);",
              "      if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
              "        continue;",
              "      }"
            ]
          }
        },
        {
          "id": "nested-loops-2367",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2367,
            "column": 32
          },
          "message": "Nested loop detected (O(n³) complexity)",
          "description": "This code has 3 nested loops, resulting in O(n³) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "extreme",
            "complexity": "O(n³)",
            "estimate": "100ms → 100s+ for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
            "context": [
              "      }",
              "      const validModes = /* @__PURE__ */ new Set([\"all\", component.mode]);",
              "      const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
              "      if (existingComponent) {",
              "        const existingPriority = existingComponent.priority ?? 0;"
            ]
          }
        },
        {
          "id": "nested-loops-2565",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2565,
            "column": 75
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "(component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
            "context": [
              "      const components = options.getComponents();",
              "      const islands = components.filter(",
              "        (component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
              "      );",
              "      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href));"
            ]
          }
        },
        {
          "id": "nested-loops-2882",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2882,
            "column": 86
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
            "context": [
              "      if (!regexpMap.has(components)) {",
              "        const serverPlaceholderPath = resolve(distDir, \"app/components/server-placeholder\");",
              "        const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
              "        regexpMap.set(components, [new RegExp(`(${clientOnlyComponents.join(\"|\")})`), new RegExp(`^(${clientOnlyComponents.map((c) => `(?:(?:_unref\\\\()?(?:_component_)?(?:Lazy|lazy_)?${c}\\\\)?)`).join(\"|\")})$`), clientOnlyComponents]);",
              "      }"
            ]
          }
        },
        {
          "id": "nested-loops-3397",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3397,
            "column": 134
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
            "context": [
              "    };",
              "    const getComponents = (mode) => {",
              "      return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
              "    };",
              "    if (nuxt.options.experimental.normalizeComponentNames) {"
            ]
          }
        },
        {
          "id": "nested-loops-3418",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3418,
            "column": 27
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const extensions = (dirOptions.extensions || nuxt.options.extensions).map((e) => e.replace(STARTER_DOT_RE, \"\"));",
            "context": [
              "        const dirOptions = typeof dir === \"object\" ? dir : { path: dir };",
              "        const dirPath = resolveAlias$1(dirOptions.path);",
              "        const extensions = (dirOptions.extensions || nuxt.options.extensions).map((e) => e.replace(STARTER_DOT_RE, \"\"));",
              "        const _transpile = typeof dirOptions.transpile === \"boolean\" ? dirOptions.transpile : \"auto\";",
              "        const transpile = _transpile === \"auto\" ? dirPath.includes(\"node_modules\") : _transpile;"
            ]
          }
        },
        {
          "id": "nested-loops-3470",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3470,
            "column": 33
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
            "context": [
              "      for (const chunk of Object.values(manifest)) {",
              "        if (chunk.isEntry) {",
              "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
              "        }",
              "      }"
            ]
          }
        },
        {
          "id": "nested-loops-3493",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3493,
            "column": 44
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
            "context": [
              "          component.filePath = resolveModulePath(resolveAlias$1(component.filePath), { try: true, extensions: nuxt.options.extensions }) ?? component.filePath;",
              "        }",
              "        if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
              "          newComponents.push({",
              "            ...component,"
            ]
          }
        },
        {
          "id": "nested-loops-3502",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3502,
            "column": 65
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
            "context": [
              "          });",
              "        }",
              "        if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
              "          logger.warn(`Using server components with \\`ssr: false\\` is not supported with auto-detected component islands. If you need to use server component \\`${component.pascalName}\\`, set \\`experimental.componentIslands\\` to \\`true\\`.`);",
              "        }"
            ]
          }
        },
        {
          "id": "nested-loops-3679",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3679,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const dir of layer.config.imports?.dirs ?? []) {",
            "context": [
              "          resolve(layer.config.rootDir, layer.config.dir?.shared ?? \"shared\", \"types\")",
              "        );",
              "        for (const dir of layer.config.imports?.dirs ?? []) {",
              "          if (dir) {",
              "            composablesDirs.push(resolve(layer.config.srcDir, resolveAlias$1(dir, nuxt.options.alias)));"
            ]
          }
        },
        {
          "id": "nested-loops-3744",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3744,
            "column": 27
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
            "context": [
              "          });",
              "          for (const i of scannedImports) {",
              "            i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
              "          }",
              "          imports.push(...scannedImports);"
            ]
          }
        },
        {
          "id": "nested-loops-3848",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3848,
            "column": 20
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
            "context": [
              "  ]);",
              "  patterns.push([/(^|node_modules\\/)@vue\\/composition-api/]);",
              "  for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
              "    patterns.push([",
              "      new RegExp(`^${escapeRE(mod)}$`),"
            ]
          }
        },
        {
          "id": "nested-loops-3986",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3986,
            "column": 27
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const fallback = ast.children?.find((n) => {",
            "context": [
              "        for (const match of code.matchAll(DEVONLY_COMP_RE)) {",
              "          const ast = parse(match[0]).children[0];",
              "          const fallback = ast.children?.find((n) => {",
              "            if (n.name !== \"template\") {",
              "              return false;"
            ]
          }
        },
        {
          "id": "nested-loops-4094",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4094,
            "column": 9
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!transpile.some((t) => t.test(path))) {",
            "context": [
              "    }",
              "    const path = normalizeModuleTranspilePath(mod);",
              "    if (!transpile.some((t) => t.test(path))) {",
              "      nuxt.options.build.transpile.push(path);",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-4329",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4329,
            "column": 10
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
            "context": [
              "    }",
              "    if (propertyKey === \"dependsOn\" && property.value.type === \"ArrayExpression\") {",
              "      if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
              "        throw new Error(\"dependsOn must take an array of string literals\");",
              "      }"
            ]
          }
        },
        {
          "id": "nested-loops-4332",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4332,
            "column": 26
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "meta[propertyKey] = property.value.elements.map((e) => e.value);",
            "context": [
              "        throw new Error(\"dependsOn must take an array of string literals\");",
              "      }",
              "      meta[propertyKey] = property.value.elements.map((e) => e.value);",
              "    }",
              "  }"
            ]
          }
        },
        {
          "id": "nested-loops-4385",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4385,
            "column": 12
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const [propertyIndex, property] of arg.properties.entries()) {",
            "context": [
              "              continue;",
              "            }",
              "            for (const [propertyIndex, property] of arg.properties.entries()) {",
              "              if (property.type === \"SpreadElement\" || !(\"name\" in property.key)) {",
              "                continue;"
            ]
          }
        },
        {
          "id": "nested-loops-4560",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4560,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const name in namedImports) {",
            "context": [
              "    }",
              "    const { namedImports = {}, defaultImport, namespacedImport } = parseStaticImport(i);",
              "    for (const name in namedImports) {",
              "      addName(namedImports[name], i.specifier);",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-4911",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4911,
            "column": 6
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const ext of extensions) {",
            "context": [
              "  const resolveWithExt = (id) => {",
              "    for (const suffix of [\"\", \".\" + options.mode]) {",
              "      for (const ext of extensions) {",
              "        const rId = id + suffix + ext;",
              "        if (rId in nuxt.vfs) {"
            ]
          }
        },
        {
          "id": "nested-loops-5063",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5063,
            "column": 23
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const config of nuxt.options._layers.map((layer) => layer.config).reverse()) {",
            "context": [
              "async function initNuxt(nuxt) {",
              "  const layerDirs = getLayerDirectories(nuxt);",
              "  for (const config of nuxt.options._layers.map((layer) => layer.config).reverse()) {",
              "    if (config.hooks) {",
              "      nuxt.hooks.addHooks(config.hooks);"
            ]
          }
        },
        {
          "id": "nested-loops-5275",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5275,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
            "context": [
              "      continue;",
              "    }",
              "    if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
              "      nuxt.options.modulesDir.push(join(dirs.root, \"node_modules\"));",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-5460",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5460,
            "column": 6
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const p of layerRelativePaths) {",
            "context": [
              "        continue;",
              "      }",
              "      for (const p of layerRelativePaths) {",
              "        if (pattern.test(p)) {",
              "          return nuxt.callHook(\"restart\");"
            ]
          }
        },
        {
          "id": "nested-loops-5611",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5611,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "while (segments.length) {",
            "context": [
              "    const key = segments.pop();",
              "    let parent = options;",
              "    while (segments.length) {",
              "      const key2 = segments.shift();",
              "      parent = parent[key2] ||= {};"
            ]
          }
        },
        {
          "id": "nested-loops-5635",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5635,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const module of definedModules) {",
            "context": [
              "  for (const config of configs) {",
              "    const definedModules = config.modules ?? [];",
              "    for (const module of definedModules) {",
              "      const resolvedModule = resolveModuleWithOptions(module, nuxt);",
              "      if (resolvedModule && (!resolvedModule.resolvedPath || !resolvedModulePaths.has(resolvedModule.resolvedPath))) {"
            ]
          }
        },
        {
          "id": "nested-loops-5650",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5650,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const module of layerModules) {",
            "context": [
              "      `*/index{${nuxt.options.extensions.join(\",\")}}`",
              "    ]);",
              "    for (const module of layerModules) {",
              "      paths.add(module);",
              "      if (!modules.has(module)) {"
            ]
          }
        },
        {
          "id": "nested-loops-5658",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5658,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const module of nuxt.options[key]) {",
            "context": [
              "  }",
              "  for (const key of [\"modules\", \"_modules\"]) {",
              "    for (const module of nuxt.options[key]) {",
              "      const resolvedModule = resolveModuleWithOptions(module, nuxt);",
              "      if (resolvedModule && !modules.has(resolvedModule.module) && (!resolvedModule.resolvedPath || !resolvedModulePaths.has(resolvedModule.resolvedPath))) {"
            ]
          }
        },
        {
          "id": "nested-loops-5938",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5938,
            "column": 166
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "modules.length > 0 && options.unresolved ? `    modules?: (undefined | null | false | NuxtModule<any> | string | [NuxtModule | string, Record<string, any>] | ${modules.map(([configKey, importName, mod]) => `[${genString(mod.meta?.rawPath || importName)}, Exclude<NuxtConfig[${configKey}], boolean>]`).join(\" | \")})[],` : \"\"",
            "context": [
              "        ];",
              "      }),",
              "      modules.length > 0 && options.unresolved ? `    modules?: (undefined | null | false | NuxtModule<any> | string | [NuxtModule | string, Record<string, any>] | ${modules.map(([configKey, importName, mod]) => `[${genString(mod.meta?.rawPath || importName)}, Exclude<NuxtConfig[${configKey}], boolean>]`).join(\" | \")})[],` : \"\"",
              "    ].filter(Boolean);",
              "    const moduleDependencies = modules.flatMap(([_configKey, importName]) => ["
            ]
          }
        },
        {
          "id": "nested-loops-6149",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6149,
            "column": 284
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const shouldEnableComponentIslands = ctx.nuxt.options.experimental.componentIslands && (ctx.nuxt.options.dev || ctx.nuxt.options.experimental.componentIslands !== \"auto\" || ctx.app.pages?.some((p) => p.mode === \"server\") || ctx.app.components?.some((c) => c.mode === \"server\" && !ctx.app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")));",
            "context": [
              "      headers: void 0",
              "    };",
              "    const shouldEnableComponentIslands = ctx.nuxt.options.experimental.componentIslands && (ctx.nuxt.options.dev || ctx.nuxt.options.experimental.componentIslands !== \"auto\" || ctx.app.pages?.some((p) => p.mode === \"server\") || ctx.app.components?.some((c) => c.mode === \"server\" && !ctx.app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")));",
              "    return [",
              "      ...Object.entries(ctx.nuxt.options.app).map(([k, v]) => `export const ${camelCase(\"app-\" + k)} = ${JSON.stringify(v)}`),"
            ]
          }
        },
        {
          "id": "nested-loops-6192",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6192,
            "column": 12
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
            "context": [
              "      if (TYPE_FILENAME_RE.test(file.filename)) {",
              "        const typeFilenames = /* @__PURE__ */ new Set([file.filename.replace(TYPE_FILENAME_RE, \".d.$1ts\"), file.filename.replace(TYPE_FILENAME_RE, \".d.ts\")]);",
              "        if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
              "          continue;",
              "        }"
            ]
          }
        },
        {
          "id": "nested-loops-6255",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6255,
            "column": 27
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (options.filter && !options.filter(template)) {",
            "context": [
              "  };",
              "  for (const template of app.templates) {",
              "    if (options.filter && !options.filter(template)) {",
              "      continue;",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-6333",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6333,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const file of layoutFiles) {",
            "context": [
              "  for (const dirs of layerDirs) {",
              "    const layoutFiles = await resolveFiles(dirs.appLayouts, `**/*{${extensionGlob}}`);",
              "    for (const file of layoutFiles) {",
              "      const name = getNameFromPath(file, dirs.appLayouts);",
              "      if (!name) {"
            ]
          }
        },
        {
          "id": "nested-loops-6348",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6348,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const file of middlewareFiles) {",
            "context": [
              "      `*/index{${extensionGlob}}`",
              "    ]);",
              "    for (const file of middlewareFiles) {",
              "      const name = getNameFromPath(file);",
              "      if (!name) {"
            ]
          }
        },
        {
          "id": "nested-loops-6362",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6362,
            "column": 20
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "plugins.push(...[",
            "context": [
              "    const config = reversedLayers[i].config;",
              "    const dirs = reversedLayerDirs[i];",
              "    plugins.push(...[",
              "      ...config.plugins || [],",
              "      ...await resolveFiles(dirs.appPlugins, ["
            ]
          }
        },
        {
          "id": "nested-loops-6372",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6372,
            "column": 9
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!plugins.some((p2) => p2.src === plugin.src)) {",
            "context": [
              "  for (const p of [...nuxt.options.plugins].reverse()) {",
              "    const plugin = normalizePlugin(p);",
              "    if (!plugins.some((p2) => p2.src === plugin.src)) {",
              "      plugins.unshift(plugin);",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-6433",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6433,
            "column": 28
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
            "context": [
              "  const pluginNames = new Set(_plugins.map((plugin) => plugin.name));",
              "  for (const plugin of _plugins) {",
              "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
              "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
              "    }"
            ]
          }
        },
        {
          "id": "nested-loops-6434",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6434,
            "column": 62
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
            "context": [
              "  for (const plugin of _plugins) {",
              "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
              "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
              "    }",
              "    if (plugin.name) {"
            ]
          }
        },
        {
          "id": "nested-loops-6589",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6589,
            "column": 38
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const normalizeFiles = (files) => files.map((f) => ({",
            "context": [
              "      })",
              "    });",
              "    const normalizeFiles = (files) => files.map((f) => ({",
              "      name: f.name,",
              "      size: f.attrs?.size,"
            ]
          }
        },
        {
          "id": "nested-loops-6897",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6897,
            "column": 8
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const event of events) {",
            "context": [
              "          return;",
              "        }",
              "        for (const event of events) {",
              "          if (isIgnored(event.path)) {",
              "            continue;"
            ]
          }
        },
        {
          "id": "nested-loops-6955",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6955,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const w of [...pathsToWatch]) {",
            "context": [
              "    const path = opts?.parentDirectories ? join(dirname(resolve(nuxt.options.srcDir, pattern)), \"\") : resolve(nuxt.options.srcDir, pattern);",
              "    let shouldAdd = true;",
              "    for (const w of [...pathsToWatch]) {",
              "      if (w.startsWith(path)) {",
              "        pathsToWatch.delete(w);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-153",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 153,
            "column": 19
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const segments = resolveComponentNameSegments(fileName.toLowerCase() === \"index\" ? \"\" : fileName, prefixParts).filter(Boolean);",
            "context": [
              "  const prefixParts = splitByCase(dirname(relativePath));",
              "  const fileName = basename(relativePath, extname(relativePath));",
              "  const segments = resolveComponentNameSegments(fileName.toLowerCase() === \"index\" ? \"\" : fileName, prefixParts).filter(Boolean);",
              "  return kebabCase(segments).replace(QUOTE_RE, \"\");",
              "}"
            ]
          }
        },
        {
          "id": "array-find-in-loop-321",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 321,
            "column": 10
          },
          "message": "Array.every() inside loop creates O(n*m) complexity",
          "description": "Using every() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.every(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
            "context": [
              "      const segment = segments[i];",
              "      const tokens = parseSegment(segment, file.absolutePath);",
              "      if (tokens.every((token) => token.type === SegmentTokenType.group)) {",
              "        continue;",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-328",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 328,
            "column": 20
          },
          "message": "Array.find() inside loop creates O(n*m) complexity",
          "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
            "context": [
              "      const routePath = getRoutePath(tokens, segments[i + 1] !== void 0 && segments[i + 1] !== \"index\");",
              "      const path = withLeadingSlash(joinURL(route.path, routePath.replace(INDEX_PAGE_RE, \"/\")));",
              "      const child = parent.find((parentRoute) => parentRoute.name === route.name && parentRoute.path === path.replace(\"([^/]*)*\", \"(.*)*\"));",
              "      if (child && child.children) {",
              "        parent = child.children;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-443",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 443,
            "column": 27
          },
          "message": "Array.find() inside loop creates O(n*m) complexity",
          "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
            "context": [
              "      if (fnName === \"definePageMeta\") {",
              "        for (const key of extractionKeys) {",
              "          const property = pageExtractArgument.properties.find((property2) => property2.type === \"Property\" && property2.key.type === \"Identifier\" && property2.key.name === key);",
              "          if (!property) {",
              "            continue;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-615",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 615,
            "column": 8
          },
          "message": "Array.find() inside loop creates O(n*m) complexity",
          "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
            "context": [
              "      route.children = prepareRoutes(route.children, route, names);",
              "    }",
              "    if (route.children?.find((childRoute) => childRoute.path === \"\")) {",
              "      delete route.name;",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-643",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 643,
            "column": 24
          },
          "message": "Array.every() inside loop creates O(n*m) complexity",
          "description": "Using every() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.every(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const skipAlias = toArray(page.alias).every((val) => !val);",
            "context": [
              "        }",
              "      }",
              "      const skipAlias = toArray(page.alias).every((val) => !val);",
              "      const route = {",
              "        path: serializeRouteValue(page.path),"
            ]
          }
        },
        {
          "id": "array-find-in-loop-903",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 903,
            "column": 27
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const name of [",
            "context": [
              "      for (const i of imports) {",
              "        const parsed = parseStaticImport(i);",
              "        for (const name of [",
              "          parsed.defaultImport,",
              "          ...Object.values(parsed.namedImports || {}),"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1008",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1008,
            "column": 80
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (prop.type === \"Property\" && prop.key.type === \"Identifier\" && options.extractedKeys?.includes(prop.key.name)) {",
            "context": [
              "            for (let i = 0; i < meta.properties.length; i++) {",
              "              const prop = meta.properties[i];",
              "              if (prop.type === \"Property\" && prop.key.type === \"Identifier\" && options.extractedKeys?.includes(prop.key.name)) {",
              "                const { serializable } = isSerializable(metaCode, prop.value);",
              "                if (!serializable) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1224",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1224,
            "column": 10
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (routerOptionsFiles.filter((p) => !p.optional).length > 0) {",
            "context": [
              "      }",
              "      const routerOptionsFiles = await resolveRouterOptions(nuxt, builtInRouterOptions);",
              "      if (routerOptionsFiles.filter((p) => !p.optional).length > 0) {",
              "        return true;",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1372",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1372,
            "column": 33
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!options2?.filter || options2.filter({ filename: \"routes.mjs\" })) {",
            "context": [
              "      }",
              "      nuxt.hook(\"app:templatesGenerated\", async (_app, _templates, options2) => {",
              "        if (!options2?.filter || options2.filter({ filename: \"routes.mjs\" })) {",
              "          await context.scanPages();",
              "        }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1435",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1435,
            "column": 12
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (page.path.includes(\":\")) {",
            "context": [
              "          prerenderRoutes.add(currentPath);",
              "        }",
              "        if (page.path.includes(\":\")) {",
              "          continue;",
              "        }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1507",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1507,
            "column": 14
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (resolvedRoutes.includes(path)) {",
            "context": [
              "          }",
              "          resolvedRoutes ||= routes.flatMap((route) => resolveRoutePaths(route));",
              "          if (resolvedRoutes.includes(path)) {",
              "            continue;",
              "          }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1537",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1537,
            "column": 34
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const getSources = (pages) => pages.filter((p) => Boolean(p.file)).flatMap(",
            "context": [
              "    }",
              "    addPlugin(resolve(runtimeDir, \"plugins/router\"));",
              "    const getSources = (pages) => pages.filter((p) => Boolean(p.file)).flatMap(",
              "      (p) => [relative(nuxt.options.srcDir, p.file), ...p.children?.length ? getSources(p.children) : []]",
              "    );"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1546",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1546,
            "column": 25
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
            "context": [
              "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
              "      for (const [key, chunk] of Object.entries(manifest)) {",
              "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
              "          delete manifest[key];",
              "          continue;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1546",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1546,
            "column": 64
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
            "context": [
              "      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : [];",
              "      for (const [key, chunk] of Object.entries(manifest)) {",
              "        if (chunk.src && Object.values(nuxt.apps).some((app) => app.pages?.some((page) => page.mode === \"server\" && page.file === join(nuxt.options.srcDir, chunk.src)))) {",
              "          delete manifest[key];",
              "          continue;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1551",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1551,
            "column": 33
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
            "context": [
              "        }",
              "        if (chunk.isEntry) {",
              "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
              "        }",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1551",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1551,
            "column": 70
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
            "context": [
              "        }",
              "        if (chunk.isEntry) {",
              "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.includes(i));",
              "        }",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1607",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1607,
            "column": 32
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
            "context": [
              "      filename: \"types/middleware.d.ts\",",
              "      getContents: ({ app }) => {",
              "        const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
              "        return [",
              "          \"import type { NavigationGuard } from 'vue-router'\","
            ]
          }
        },
        {
          "id": "array-find-in-loop-1622",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1622,
            "column": 32
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
            "context": [
              "      filename: \"types/nitro-middleware.d.ts\",",
              "      getContents: ({ app }) => {",
              "        const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
              "        return [",
              "          `export type MiddlewareKey = ${namedMiddleware.map((mw) => genString(mw.name)).join(\" | \") || \"never\"}`,"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1744",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1744,
            "column": 34
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
            "context": [
              "          }",
              "        });",
              "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        if (importsFromUnhead.length) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1744",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1744,
            "column": 69
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
            "context": [
              "          }",
              "        });",
              "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        if (importsFromUnhead.length) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1745",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1745,
            "column": 32
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
            "context": [
              "        });",
              "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        if (importsFromUnhead.length) {",
              "          if (!normalize(id).includes(\"node_modules\")) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-1745",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1745,
            "column": 68
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
            "context": [
              "        });",
              "        const importsFromUnhead = importsToAdd.filter((specifier) => unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        const importsFromHead = importsToAdd.filter((specifier) => !unheadVueComposablesImports[UnheadVue].includes(specifier.imported?.name));",
              "        if (importsFromUnhead.length) {",
              "          if (!normalize(id).includes(\"node_modules\")) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2108",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2108,
            "column": 9
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return [",
            "context": [
              "const createImportMagicComments = (options) => {",
              "  const { chunkName, prefetch, preload } = options;",
              "  return [",
              "    `webpackChunkName: \"${chunkName}\"`,",
              "    prefetch === true || typeof prefetch === \"number\" ? `webpackPrefetch: ${prefetch}` : false,"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2176",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2176,
            "column": 20
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const islands = components.filter(",
            "context": [
              "    const components = app.components;",
              "    const pages = app.pages;",
              "    const islands = components.filter(",
              "      (component) => component.island || // .server components without a corresponding .client component will need to be rendered as an island",
              "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2178",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2178,
            "column": 38
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
            "context": [
              "    const islands = components.filter(",
              "      (component) => component.island || // .server components without a corresponding .client component will need to be rendered as an island",
              "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
              "    );",
              "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2180",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2180,
            "column": 24
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
            "context": [
              "      component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
              "    );",
              "    const pageExports = pages?.filter((p) => p.mode === \"server\" && p.file && p.name).map((p) => {",
              "      return `\"page_${p.name}\": defineAsyncComponent(${genDynamicImport(p.file)}.then(c => c.default || c))`;",
              "    }) || [];"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2208",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2208,
            "column": 10
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
            "context": [
              "    let type = `typeof ${genDynamicImport(isAbsolute(filePath) ? relative(baseDir, filePath).replace(NON_VUE_RE, \"\") : filePath.replace(NON_VUE_RE, \"\"), { wrapper: false })}['${c.export}']`;",
              "    if (c.mode === \"server\") {",
              "      if (app.components.some((other) => other.pascalName === c.pascalName && other.mode === \"client\")) {",
              "        if (c.filePath.startsWith(serverPlaceholderPath)) {",
              "          continue;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2306",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2306,
            "column": 10
          },
          "message": "Array.find() inside loop creates O(n*m) complexity",
          "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
            "context": [
              "    for (const _file of files) {",
              "      const filePath = join(dir.path, _file);",
              "      if (scannedPaths.find((d) => filePath.startsWith(withTrailingSlash$1(d))) || isIgnored(filePath)) {",
              "        continue;",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2367",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2367,
            "column": 32
          },
          "message": "Array.find() inside loop creates O(n*m) complexity",
          "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
            "context": [
              "      }",
              "      const validModes = /* @__PURE__ */ new Set([\"all\", component.mode]);",
              "      const existingComponent = components.find((c) => c.pascalName === component.pascalName && validModes.has(c.mode));",
              "      if (existingComponent) {",
              "        const existingPriority = existingComponent.priority ?? 0;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2372",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2372,
            "column": 28
          },
          "message": "Array.indexOf() inside loop creates O(n*m) complexity",
          "description": "Using indexOf() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.indexOf(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "components.splice(components.indexOf(existingComponent), 1, component);",
            "context": [
              "        const newPriority = component.priority ?? 0;",
              "        if (newPriority > existingPriority) {",
              "          components.splice(components.indexOf(existingComponent), 1, component);",
              "        }",
              "        if (newPriority > 0 && newPriority === existingPriority) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2564",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2564,
            "column": 22
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const islands = components.filter(",
            "context": [
              "      }",
              "      const components = options.getComponents();",
              "      const islands = components.filter(",
              "        (component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
              "      );"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2565",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2565,
            "column": 75
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "(component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
            "context": [
              "      const components = options.getComponents();",
              "      const islands = components.filter(",
              "        (component) => component.island || component.mode === \"server\" && !components.some((c) => c.pascalName === component.pascalName && c.mode === \"client\")",
              "      );",
              "      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href));"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2782",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2782,
            "column": 25
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "from: withMode([mode, \"async\"].filter(Boolean).join(\",\")),",
            "context": [
              "        {",
              "          as: \"Lazy\" + c.pascalName,",
              "          from: withMode([mode, \"async\"].filter(Boolean).join(\",\")),",
              "          name: c.export || \"default\"",
              "        }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2882",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2882,
            "column": 37
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
            "context": [
              "      if (!regexpMap.has(components)) {",
              "        const serverPlaceholderPath = resolve(distDir, \"app/components/server-placeholder\");",
              "        const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
              "        regexpMap.set(components, [new RegExp(`(${clientOnlyComponents.join(\"|\")})`), new RegExp(`^(${clientOnlyComponents.map((c) => `(?:(?:_unref\\\\()?(?:_component_)?(?:Lazy|lazy_)?${c}\\\\)?)`).join(\"|\")})$`), clientOnlyComponents]);",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2882",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2882,
            "column": 86
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
            "context": [
              "      if (!regexpMap.has(components)) {",
              "        const serverPlaceholderPath = resolve(distDir, \"app/components/server-placeholder\");",
              "        const clientOnlyComponents = components.filter((c) => c.mode === \"client\" && !components.some((other) => other.mode !== \"client\" && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath))).flatMap((c) => [c.pascalName, c.kebabName.replaceAll(\"-\", \"_\")]).concat([\"ClientOnly\", \"client_only\"]);",
              "        regexpMap.set(components, [new RegExp(`(${clientOnlyComponents.join(\"|\")})`), new RegExp(`^(${clientOnlyComponents.map((c) => `(?:(?:_unref\\\\()?(?:_component_)?(?:Lazy|lazy_)?${c}\\\\)?)`).join(\"|\")})$`), clientOnlyComponents]);",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2905",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2905,
            "column": 56
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const slotsToRemove = isClientOnlyComponent ? children.properties.filter((prop) => prop.type === \"Property\" && prop.key.type === \"Identifier\" && !PLACEHOLDER_EXACT_RE.test(prop.key.name)) : children.properties;",
            "context": [
              "          }",
              "          const isClientOnlyComponent = CLIENT_ONLY_NAME_RE.test(componentName);",
              "          const slotsToRemove = isClientOnlyComponent ? children.properties.filter((prop) => prop.type === \"Property\" && prop.key.type === \"Identifier\" && !PLACEHOLDER_EXACT_RE.test(prop.key.name)) : children.properties;",
              "          for (const slot of slotsToRemove) {",
              "            s.remove(slot.start, slot.end + 1);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2955",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2955,
            "column": 31
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const variableList = node.value.body.body.filter((statement) => statement.type === \"VariableDeclaration\");",
            "context": [
              "            removePropertyFromObject(returnStatement.argument, name, magicString);",
              "          }",
              "          const variableList = node.value.body.body.filter((statement) => statement.type === \"VariableDeclaration\");",
              "          const returnedVariableDeclaration = variableList.find((declaration) => declaration.declarations[0]?.id.type === \"Identifier\" && declaration.declarations[0]?.id.name === \"__returned__\" && declaration.declarations[0]?.init?.type === \"ObjectExpression\");",
              "          if (returnedVariableDeclaration) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-2985",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 2985,
            "column": 27
          },
          "message": "Array.findIndex() inside loop creates O(n*m) complexity",
          "description": "Using findIndex() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.findIndex(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const specifierIndex = node.specifiers.findIndex((s) => s.local.name === importName);",
            "context": [
              "      continue;",
              "    }",
              "    const specifierIndex = node.specifiers.findIndex((s) => s.local.name === importName);",
              "    if (specifierIndex > -1) {",
              "      if (node.specifiers.length > 1) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3060",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3060,
            "column": 21
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const elements = node.elements.filter((e) => e !== null && !removedNodeSet.has(e));",
            "context": [
              "    }",
              "  } else if (node.type === \"ArrayPattern\") {",
              "    const elements = node.elements.filter((e) => e !== null && !removedNodeSet.has(e));",
              "    for (const element of elements) {",
              "      const matched = findMatchingPatternToRemove(element, elements.length > 1 ? element : toRemoveIfMatched, name, removedNodeSet);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3068",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3068,
            "column": 23
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const properties = node.properties.filter((e) => e.type === \"Property\" && !removedNodeSet.has(e));",
            "context": [
              "    }",
              "  } else if (node.type === \"ObjectPattern\") {",
              "    const properties = node.properties.filter((e) => e.type === \"Property\" && !removedNodeSet.has(e));",
              "    for (const [index, property] of properties.entries()) {",
              "      let nodeToRemove = property;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3379",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3379,
            "column": 9
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
            "context": [
              "const SLASH_SEPARATOR_RE = /[\\\\/]/;",
              "function compareDirByPathLength({ path: pathA }, { path: pathB }) {",
              "  return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
              "}",
              "const DEFAULT_COMPONENTS_DIRS_RE = /\\/components(?:\\/(?:global|islands))?$/;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3379",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3379,
            "column": 66
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
            "context": [
              "const SLASH_SEPARATOR_RE = /[\\\\/]/;",
              "function compareDirByPathLength({ path: pathA }, { path: pathB }) {",
              "  return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length;",
              "}",
              "const DEFAULT_COMPONENTS_DIRS_RE = /\\/components(?:\\/(?:global|islands))?$/;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3397",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3397,
            "column": 38
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
            "context": [
              "    };",
              "    const getComponents = (mode) => {",
              "      return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
              "    };",
              "    if (nuxt.options.experimental.normalizeComponentNames) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3397",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3397,
            "column": 134
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
            "context": [
              "    };",
              "    const getComponents = (mode) => {",
              "      return mode && mode !== \"all\" ? context.components.filter((c) => c.mode === mode || c.mode === \"all\" || c.mode === \"server\" && !context.components.some((otherComponent) => otherComponent.mode !== \"server\" && otherComponent.pascalName === c.pascalName)) : context.components;",
              "    };",
              "    if (nuxt.options.experimental.normalizeComponentNames) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3420",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3420,
            "column": 50
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const transpile = _transpile === \"auto\" ? dirPath.includes(\"node_modules\") : _transpile;",
            "context": [
              "        const extensions = (dirOptions.extensions || nuxt.options.extensions).map((e) => e.replace(STARTER_DOT_RE, \"\"));",
              "        const _transpile = typeof dirOptions.transpile === \"boolean\" ? dirOptions.transpile : \"auto\";",
              "        const transpile = _transpile === \"auto\" ? dirPath.includes(\"node_modules\") : _transpile;",
              "        if (transpile) {",
              "          nuxt.options.build.transpile.push(dirPath);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3428",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3428,
            "column": 21
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const dirs = dirPath.includes(\"node_modules\") ? libraryComponentDirs : userComponentDirs;",
            "context": [
              "          logger.warn(\"Components directory not found: `\" + dirPath + \"`\");",
              "        }",
              "        const dirs = dirPath.includes(\"node_modules\") ? libraryComponentDirs : userComponentDirs;",
              "        dirs.push({",
              "          global: moduleOptions.global,"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3470",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3470,
            "column": 33
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
            "context": [
              "      for (const chunk of Object.values(manifest)) {",
              "        if (chunk.isEntry) {",
              "          chunk.dynamicImports = chunk.dynamicImports?.filter((i) => !sourceFiles.has(i));",
              "        }",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3493",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3493,
            "column": 44
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
            "context": [
              "          component.filePath = resolveModulePath(resolveAlias$1(component.filePath), { try: true, extensions: nuxt.options.extensions }) ?? component.filePath;",
              "        }",
              "        if (component.mode === \"client\" && !newComponents.some((c) => c.pascalName === component.pascalName && c.mode === \"server\")) {",
              "          newComponents.push({",
              "            ...component,"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3502",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3502,
            "column": 65
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
            "context": [
              "          });",
              "        }",
              "        if (component.mode === \"server\" && !nuxt.options.ssr && !newComponents.some((other) => other.pascalName === component.pascalName && other.mode === \"client\")) {",
              "          logger.warn(`Using server components with \\`ssr: false\\` is not supported with auto-detected component islands. If you need to use server component \\`${component.pascalName}\\`, set \\`experimental.componentIslands\\` to \\`true\\`.`);",
              "        }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3744",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3744,
            "column": 27
          },
          "message": "Array.find() inside loop creates O(n*m) complexity",
          "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
            "context": [
              "          });",
              "          for (const i of scannedImports) {",
              "            i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1];",
              "          }",
              "          imports.push(...scannedImports);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3848",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3848,
            "column": 20
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
            "context": [
              "  ]);",
              "  patterns.push([/(^|node_modules\\/)@vue\\/composition-api/]);",
              "  for (const mod of nuxt.options.modules.filter((m) => typeof m === \"string\")) {",
              "    patterns.push([",
              "      new RegExp(`^${escapeRE(mod)}$`),"
            ]
          }
        },
        {
          "id": "array-find-in-loop-3986",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3986,
            "column": 27
          },
          "message": "Array.find() inside loop creates O(n*m) complexity",
          "description": "Using find() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.find(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const fallback = ast.children?.find((n) => {",
            "context": [
              "        for (const match of code.matchAll(DEVONLY_COMP_RE)) {",
              "          const ast = parse(match[0]).children[0];",
              "          const fallback = ast.children?.find((n) => {",
              "            if (n.name !== \"template\") {",
              "              return false;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-4094",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4094,
            "column": 9
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!transpile.some((t) => t.test(path))) {",
            "context": [
              "    }",
              "    const path = normalizeModuleTranspilePath(mod);",
              "    if (!transpile.some((t) => t.test(path))) {",
              "      nuxt.options.build.transpile.push(path);",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-4329",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4329,
            "column": 10
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
            "context": [
              "    }",
              "    if (propertyKey === \"dependsOn\" && property.value.type === \"ArrayExpression\") {",
              "      if (property.value.elements.some((e) => !e || e.type !== \"Literal\" || typeof e.value !== \"string\")) {",
              "        throw new Error(\"dependsOn must take an array of string literals\");",
              "      }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5265",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5265,
            "column": 8
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (layer.root.includes(\"node_modules\")) {",
            "context": [
              "  nuxt.options.build.transpile.push(\"nuxt/app\");",
              "  for (const layer of layerDirs) {",
              "    if (layer.root.includes(\"node_modules\")) {",
              "      nuxt.options.build.transpile.push(layer.root.replace(/\\/$/, \"\"));",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5275",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5275,
            "column": 8
          },
          "message": "Array.every() inside loop creates O(n*m) complexity",
          "description": "Using every() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.every(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
            "context": [
              "      continue;",
              "    }",
              "    if (locallyScannedLayersDirs.every((dir) => !dirs.root.startsWith(dir))) {",
              "      nuxt.options.modulesDir.push(join(dirs.root, \"node_modules\"));",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5387",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5387,
            "column": 21
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
            "context": [
              "  nuxt._ignore.add(resolveIgnorePatterns());",
              "  await nuxt.callHook(\"modules:done\");",
              "  nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
              "  if (nuxt.options.experimental.componentIslands) {",
              "    addComponent({"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5387",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5387,
            "column": 71
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
            "context": [
              "  nuxt._ignore.add(resolveIgnorePatterns());",
              "  await nuxt.callHook(\"modules:done\");",
              "  nuxt.options.css = nuxt.options.css.filter((value, index, array) => !array.includes(value, index + 1));",
              "  if (nuxt.options.experimental.componentIslands) {",
              "    addComponent({"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5530",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5530,
            "column": 21
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (layer.cwd && layer.cwd.includes(\"node_modules\")) {",
            "context": [
              "  const importIncludes = [];",
              "  for (const layer of options._layers) {",
              "    if (layer.cwd && layer.cwd.includes(\"node_modules\")) {",
              "      importIncludes.push(new RegExp(`(^|\\\\/)${escapeRE(layer.cwd.split(\"node_modules/\").pop())}(\\\\/|$)(?!node_modules\\\\/)`));",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5744",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5744,
            "column": 58
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const clientPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"server\"));",
            "context": [
              "  filename: \"plugins.client.mjs\",",
              "  async getContents(ctx) {",
              "    const clientPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"server\"));",
              "    checkForCircularDependencies(clientPlugins);",
              "    const exports = [];"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5763",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5763,
            "column": 58
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const serverPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"client\"));",
            "context": [
              "  filename: \"plugins.server.mjs\",",
              "  async getContents(ctx) {",
              "    const serverPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter((p) => !p.mode || p.mode !== \"client\"));",
              "    checkForCircularDependencies(serverPlugins);",
              "    const exports = [];"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5907",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5907,
            "column": 48
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const moduleOptionsInterface = (options) => [",
            "context": [
              "      modules.push([genString(m.meta.configKey), getImportName(m.entryPath || m.meta.name), m]);",
              "    }",
              "    const moduleOptionsInterface = (options) => [",
              "      ...modules.flatMap(([configKey, importName, mod]) => {",
              "        let link;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5987",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5987,
            "column": 29
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const globalMiddleware = app.middleware.filter((mw) => mw.global);",
            "context": [
              "  filename: \"middleware.mjs\",",
              "  getContents({ app, nuxt }) {",
              "    const globalMiddleware = app.middleware.filter((mw) => mw.global);",
              "    const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
              "    const alias = nuxt.options.dev ? { ...nuxt?.options.alias || {}, ...strippedAtAliases } : {};"
            ]
          }
        },
        {
          "id": "array-find-in-loop-5988",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5988,
            "column": 28
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
            "context": [
              "  getContents({ app, nuxt }) {",
              "    const globalMiddleware = app.middleware.filter((mw) => mw.global);",
              "    const namedMiddleware = app.middleware.filter((mw) => !mw.global);",
              "    const alias = nuxt.options.dev ? { ...nuxt?.options.alias || {}, ...strippedAtAliases } : {};",
              "    return ["
            ]
          }
        },
        {
          "id": "array-find-in-loop-6098",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6098,
            "column": 11
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return [",
            "context": [
              "  filename: \"paths.mjs\",",
              "  getContents({ nuxt }) {",
              "    return [",
              "      \"import { joinRelativeURL } from 'ufo'\",",
              "      !nuxt.options.dev && \"import { useRuntimeConfig } from 'nitropack/runtime'\","
            ]
          }
        },
        {
          "id": "array-find-in-loop-6192",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6192,
            "column": 12
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
            "context": [
              "      if (TYPE_FILENAME_RE.test(file.filename)) {",
              "        const typeFilenames = /* @__PURE__ */ new Set([file.filename.replace(TYPE_FILENAME_RE, \".d.$1ts\"), file.filename.replace(TYPE_FILENAME_RE, \".d.ts\")]);",
              "        if (app.templates.some((f) => f.filename && typeFilenames.has(f.filename))) {",
              "          continue;",
              "        }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-6255",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6255,
            "column": 27
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (options.filter && !options.filter(template)) {",
            "context": [
              "  };",
              "  for (const template of app.templates) {",
              "    if (options.filter && !options.filter(template)) {",
              "      continue;",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-6372",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6372,
            "column": 9
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!plugins.some((p2) => p2.src === plugin.src)) {",
            "context": [
              "  for (const p of [...nuxt.options.plugins].reverse()) {",
              "    const plugin = normalizePlugin(p);",
              "    if (!plugins.some((p2) => p2.src === plugin.src)) {",
              "      plugins.unshift(plugin);",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-6433",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6433,
            "column": 28
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
            "context": [
              "  const pluginNames = new Set(_plugins.map((plugin) => plugin.name));",
              "  for (const plugin of _plugins) {",
              "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
              "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-6434",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6434,
            "column": 62
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
            "context": [
              "  for (const plugin of _plugins) {",
              "    if (plugin.dependsOn && plugin.dependsOn.some((name) => !pluginNames.has(name))) {",
              "      console.error(`Plugin \\`${plugin.name}\\` depends on \\`${plugin.dependsOn.filter((name) => !pluginNames.has(name)).join(\", \")}\\` but they are not registered.`);",
              "    }",
              "    if (plugin.name) {"
            ]
          }
        },
        {
          "id": "array-find-in-loop-6455",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6455,
            "column": 26
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const warningMessages = checkResults.filter(Boolean);",
            "context": [
              "async function checkForExternalConfigurationFiles() {",
              "  const checkResults = await Promise.all([checkViteConfig(), checkWebpackConfig(), checkNitroConfig(), checkPostCSSConfig()]);",
              "  const warningMessages = checkResults.filter(Boolean);",
              "  if (!warningMessages.length) {",
              "    return;"
            ]
          }
        },
        {
          "id": "array-find-in-loop-6578",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6578,
            "column": 8
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (layer.cwd.includes(\"node_modules\")) {",
            "context": [
              "  let layerCtr = 0;",
              "  for (const layer of nuxt.options._layers) {",
              "    if (layer.cwd.includes(\"node_modules\")) {",
              "      continue;",
              "    }"
            ]
          }
        },
        {
          "id": "array-find-in-loop-6652",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6652,
            "column": 9
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return fileEntries.filter(Boolean);",
            "context": [
              "    }",
              "  }));",
              "  return fileEntries.filter(Boolean);",
              "}",
              "async function readFileWithMeta(dir, fileName, count = 0) {"
            ]
          }
        },
        {
          "id": "sync-file-op-346",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 346,
            "column": 64
          },
          "message": "readFileSync() blocks the event loop",
          "description": "Synchronous operations like readFileSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: readFile()",
            "example": "// Instead of:\nconst data = fs.readFileSync('file.txt')\n\n// Use:\nconst data = await fs.promises.readFile('file.txt')\n// or\nfs.readFile('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const fileContent = route.file in vfs ? vfs[route.file] : fs.readFileSync(ctx.fullyResolvedPaths?.has(route.file) ? route.file : await resolvePath(route.file), \"utf-8\");",
            "context": [
              "  for (const route of routes) {",
              "    if (route.file && !ctx.pagesToSkip?.has(route.file)) {",
              "      const fileContent = route.file in vfs ? vfs[route.file] : fs.readFileSync(ctx.fullyResolvedPaths?.has(route.file) ? route.file : await resolvePath(route.file), \"utf-8\");",
              "      const routeMeta = getRouteMeta(fileContent, route.file, ctx.extraExtractionKeys);",
              "      if (route.meta) {"
            ]
          }
        },
        {
          "id": "sync-file-op-1217",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1217,
            "column": 35
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
            "context": [
              "      delete tsConfig.compilerOptions.paths[\"#vue-router/*\"];",
              "    });",
              "    const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
              "    const userPreference = options.enabled;",
              "    const isPagesEnabled = async () => {"
            ]
          }
        },
        {
          "id": "sync-file-op-1217",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 1217,
            "column": 54
          },
          "message": "readdirSync() blocks the event loop",
          "description": "Synchronous operations like readdirSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: readdir()",
            "example": "// Instead of:\nconst data = fs.readdirSync('file.txt')\n\n// Use:\nconst data = await fs.promises.readdir('file.txt')\n// or\nfs.readdir('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
            "context": [
              "      delete tsConfig.compilerOptions.paths[\"#vue-router/*\"];",
              "    });",
              "    const isNonEmptyDir = (dir) => existsSync(dir) && readdirSync(dir).length;",
              "    const userPreference = options.enabled;",
              "    const isPagesEnabled = async () => {"
            ]
          }
        },
        {
          "id": "sync-file-op-3372",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3372,
            "column": 11
          },
          "message": "statSync() blocks the event loop",
          "description": "Synchronous operations like statSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: stat()",
            "example": "// Instead of:\nconst data = fs.statSync('file.txt')\n\n// Use:\nconst data = await fs.promises.stat('file.txt')\n// or\nfs.stat('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return statSync(p).isDirectory();",
            "context": [
              "const isDirectory = (p) => {",
              "  try {",
              "    return statSync(p).isDirectory();",
              "  } catch {",
              "    return false;"
            ]
          }
        },
        {
          "id": "sync-file-op-3490",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3490,
            "column": 107
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!component._scanned && !(component.filePath in nuxt.vfs) && isAbsolute(component.filePath) && !existsSync(component.filePath)) {",
            "context": [
              "      await nuxt.callHook(\"components:extend\", newComponents);",
              "      for (const component of newComponents) {",
              "        if (!component._scanned && !(component.filePath in nuxt.vfs) && isAbsolute(component.filePath) && !existsSync(component.filePath)) {",
              "          component.filePath = resolveModulePath(resolveAlias$1(component.filePath), { try: true, extensions: nuxt.options.extensions }) ?? component.filePath;",
              "        }"
            ]
          }
        },
        {
          "id": "sync-file-op-3811",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 3811,
            "column": 10
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (existsSync(path) && !await isDirectory$1(path)) {",
            "context": [
              "        }) ?? path;",
              "      }",
              "      if (existsSync(path) && !await isDirectory$1(path)) {",
              "        path = path.replace(SUPPORTED_EXTENSION_RE, \"\");",
              "      }"
            ]
          }
        },
        {
          "id": "sync-file-op-4192",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 4192,
            "column": 24
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (filePath && existsSync(filePath)) {",
            "context": [
              "      for (const dirs of layerDirs) {",
              "        const filePath = await resolver.resolvePath(join(dirs.root, \"nuxt.schema\"));",
              "        if (filePath && existsSync(filePath)) {",
              "          let loadedConfig;",
              "          try {"
            ]
          }
        },
        {
          "id": "sync-file-op-5149",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5149,
            "column": 10
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (existsSync(declaration)) {",
            "context": [
              "    for (const dirs of layerDirs) {",
              "      const declaration = join(dirs.root, \"index.d.ts\");",
              "      if (existsSync(declaration)) {",
              "        opts.references.push({ path: declaration });",
              "        opts.nodeReferences.push({ path: declaration });"
            ]
          }
        },
        {
          "id": "sync-file-op-5791",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 5791,
            "column": 69
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return app.templates.some((t) => t.write && path === t.dst) || existsSync(path);",
            "context": [
              "    const pluginNames = [];",
              "    function exists(path) {",
              "      return app.templates.some((t) => t.write && path === t.dst) || existsSync(path);",
              "    }",
              "    for (const plugin of await annotatePlugins(nuxt, app.plugins)) {"
            ]
          }
        },
        {
          "id": "sync-file-op-6292",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6292,
            "column": 24
          },
          "message": "writeFileSync() blocks the event loop",
          "description": "Synchronous operations like writeFileSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: writeFile()",
            "example": "// Instead of:\nconst data = fs.writeFileSync('file.txt')\n\n// Use:\nconst data = await fs.promises.writeFile('file.txt')\n// or\nfs.writeFile('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "writes.push(() => writeFileSync(fullPath, contents, \"utf8\"));",
            "context": [
              "    if (template.modified && template.write) {",
              "      dirs.add(dirname(fullPath));",
              "      writes.push(() => writeFileSync(fullPath, contents, \"utf8\"));",
              "    }",
              "  }"
            ]
          }
        },
        {
          "id": "sync-file-op-6298",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6298,
            "column": 4
          },
          "message": "mkdirSync() blocks the event loop",
          "description": "Synchronous operations like mkdirSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: mkdir()",
            "example": "// Instead of:\nconst data = fs.mkdirSync('file.txt')\n\n// Use:\nconst data = await fs.promises.mkdir('file.txt')\n// or\nfs.mkdir('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "mkdirSync(dir, { recursive: true });",
            "context": [
              "  await Promise.allSettled(filteredTemplates.post.map(processTemplate));",
              "  for (const dir of dirs) {",
              "    mkdirSync(dir, { recursive: true });",
              "  }",
              "  for (const write of writes) {"
            ]
          }
        },
        {
          "id": "sync-file-op-6686",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6686,
            "column": 7
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!existsSync(cacheFile)) {",
            "context": [
              "}",
              "async function restoreCache(cwd, cacheFile) {",
              "  if (!existsSync(cacheFile)) {",
              "    return false;",
              "  }"
            ]
          }
        },
        {
          "id": "sync-file-op-6724",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6724,
            "column": 7
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (!existsSync(cacheDir)) {",
            "context": [
              "function getCacheDir(nuxt) {",
              "  let cacheDir = join(nuxt.options.workspaceDir, \"node_modules\");",
              "  if (!existsSync(cacheDir)) {",
              "    for (const dir of [...nuxt.options.modulesDir].sort((a, b) => a.length - b.length)) {",
              "      if (existsSync(dir)) {"
            ]
          }
        },
        {
          "id": "sync-file-op-6726",
          "rule": "sync-file-operations",
          "severity": "critical",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 6726,
            "column": 10
          },
          "message": "existsSync() blocks the event loop",
          "description": "Synchronous operations like existsSync() block the entire Node.js event loop. During this time, the server cannot handle ANY other requests. This is especially critical in API routes and middleware.",
          "impact": {
            "type": "io",
            "level": "extreme",
            "blocking": true,
            "estimate": "50-200ms block"
          },
          "suggestion": {
            "fix": "Use async version: exists()",
            "example": "// Instead of:\nconst data = fs.existsSync('file.txt')\n\n// Use:\nconst data = await fs.promises.exists('file.txt')\n// or\nfs.exists('file.txt', (err, data) => {...})",
            "docs": "https://github.com/productdevbook/ceviz#sync-file-operations"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (existsSync(dir)) {",
            "context": [
              "  if (!existsSync(cacheDir)) {",
              "    for (const dir of [...nuxt.options.modulesDir].sort((a, b) => a.length - b.length)) {",
              "      if (existsSync(dir)) {",
              "        cacheDir = dir;",
              "        break;"
            ]
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "4 sequential await calls create waterfall",
          "description": "These 4 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "4x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "13 sequential await calls create waterfall",
          "description": "These 13 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "13x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "4 sequential await calls create waterfall",
          "description": "These 4 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "4x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "4 sequential await calls create waterfall",
          "description": "These 4 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "4x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/index.mjs",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/bin/nuxt.mjs",
      "size": 43,
      "lines": 3,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/utils.js",
      "size": 1000,
      "lines": 35,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/types.js",
      "size": 0,
      "lines": 1,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
      "size": 9264,
      "lines": 280,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "nested-loops-153",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
            "line": 153,
            "column": 78
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
            "context": [
              "  let promiseDepth = 0;",
              "  async function executePlugin(plugin) {",
              "    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
              "    if (unresolvedPluginsForThisPlugin.length > 0) {",
              "      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-153",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
            "line": 153,
            "column": 43
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
            "context": [
              "  let promiseDepth = 0;",
              "  async function executePlugin(plugin) {",
              "    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
              "    if (unresolvedPluginsForThisPlugin.length > 0) {",
              "      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-153",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
            "line": 153,
            "column": 78
          },
          "message": "Array.some() inside loop creates O(n*m) complexity",
          "description": "Using some() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.some(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
            "context": [
              "  let promiseDepth = 0;",
              "  async function executePlugin(plugin) {",
              "    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];",
              "    if (unresolvedPluginsForThisPlugin.length > 0) {",
              "      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);"
            ]
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/nuxt.js",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/index.js",
      "size": 1488,
      "lines": 9,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
      "size": 2793,
      "lines": 79,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry.async.js",
      "size": 207,
      "lines": 6,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/entry-spa.js",
      "size": 26,
      "lines": 3,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/config.js",
      "size": 2004,
      "lines": 73,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/validate.js",
      "size": 697,
      "lines": 24,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/utils.js",
      "size": 1032,
      "lines": 19,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/router.options.js",
      "size": 2102,
      "lines": 61,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/page.js",
      "size": 8053,
      "lines": 208,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/page-placeholder.js",
      "size": 357,
      "lines": 12,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/index.js",
      "size": 69,
      "lines": 2,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/composables.js",
      "size": 1008,
      "lines": 25,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/component-stub.js",
      "size": 19,
      "lines": 2,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/app.vue",
      "size": 98,
      "lines": 7,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/app.d.vue.ts",
      "size": 369,
      "lines": 4,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/head/runtime/types.js",
      "size": 0,
      "lines": 1,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/head/runtime/composables.js",
      "size": 1626,
      "lines": 48,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/head/runtime/components.js",
      "size": 7300,
      "lines": 298,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "array-find-in-loop-13",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/head/runtime/components.js",
            "line": 13,
            "column": 4
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "Object.entries(_props).filter(([_, value]) => value !== void 0)",
            "context": [
              "const normalizeProps = (_props) => {",
              "  const props = Object.fromEntries(",
              "    Object.entries(_props).filter(([_, value]) => value !== void 0)",
              "  );",
              "  if (typeof props.body !== \"undefined\") {"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/components/runtime/server-component.js",
      "size": 2164,
      "lines": 70,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/components/runtime/lazy-hydrated-component.js",
      "size": 2950,
      "lines": 102,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/components/runtime/client-component.js",
      "size": 2135,
      "lines": 60,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/types/augments.js",
      "size": 0,
      "lines": 1,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/middleware/manifest-route-rule.js",
      "size": 598,
      "lines": 18,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/warn.dev.server.js",
      "size": 219,
      "lines": 7,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/view-transitions.client.js",
      "size": 1943,
      "lines": 56,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/utils.js",
      "size": 188,
      "lines": 5,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
      "size": 8156,
      "lines": 223,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/revive-payload.server.js",
      "size": 1318,
      "lines": 27,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/revive-payload.client.js",
      "size": 1575,
      "lines": 45,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/restore-state.client.js",
      "size": 494,
      "lines": 19,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/preload.server.js",
      "size": 352,
      "lines": 14,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/payload.client.js",
      "size": 1651,
      "lines": 51,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "memory-leak-interval-46",
          "rule": "memory-leak-interval",
          "severity": "critical",
          "category": "memory",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/payload.client.js",
            "line": 46,
            "column": 0
          },
          "message": "setInterval/setTimeout without cleanup causes memory leak",
          "description": "This interval/timeout is never cleared, causing a memory leak. In components, this will accumulate on every mount/unmount cycle.",
          "impact": {
            "type": "memory",
            "level": "extreme",
            "estimate": "Memory grows indefinitely, ~1-10MB per instance"
          },
          "suggestion": {
            "fix": "Clear interval/timeout in cleanup lifecycle (onUnmounted, useEffect return, etc.)",
            "example": "// React:\nuseEffect(() => {\n  const interval = setInterval(() => {...}, 1000)\n  return () => clearInterval(interval)\n}, [])",
            "docs": "https://github.com/productdevbook/ceviz#memory-leak-interval"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "setTimeout(getAppManifest, 1e3);",
            "context": [
              "      });",
              "      if (isAppManifestEnabled && navigator.connection?.effectiveType !== \"slow-2g\") {",
              "        setTimeout(getAppManifest, 1e3);",
              "      }",
              "    });"
            ]
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/payload.client.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/navigation-repaint.client.js",
      "size": 472,
      "lines": 17,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "memory-leak-interval-9",
          "rule": "memory-leak-interval",
          "severity": "critical",
          "category": "memory",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/navigation-repaint.client.js",
            "line": 9,
            "column": 0
          },
          "message": "setInterval/setTimeout without cleanup causes memory leak",
          "description": "This interval/timeout is never cleared, causing a memory leak. In components, this will accumulate on every mount/unmount cycle.",
          "impact": {
            "type": "memory",
            "level": "extreme",
            "estimate": "Memory grows indefinitely, ~1-10MB per instance"
          },
          "suggestion": {
            "fix": "Clear interval/timeout in cleanup lifecycle (onUnmounted, useEffect return, etc.)",
            "example": "// React:\nuseEffect(() => {\n  const interval = setInterval(() => {...}, 1000)\n  return () => clearInterval(interval)\n}, [])",
            "docs": "https://github.com/productdevbook/ceviz#memory-leak-interval"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "setTimeout(resolve, 100);",
            "context": [
              "    router.beforeResolve(async () => {",
              "      await new Promise((resolve) => {",
              "        setTimeout(resolve, 100);",
              "        requestAnimationFrame(() => {",
              "          setTimeout(resolve, 0);"
            ]
          }
        },
        {
          "id": "memory-leak-interval-11",
          "rule": "memory-leak-interval",
          "severity": "critical",
          "category": "memory",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/navigation-repaint.client.js",
            "line": 11,
            "column": 0
          },
          "message": "setInterval/setTimeout without cleanup causes memory leak",
          "description": "This interval/timeout is never cleared, causing a memory leak. In components, this will accumulate on every mount/unmount cycle.",
          "impact": {
            "type": "memory",
            "level": "extreme",
            "estimate": "Memory grows indefinitely, ~1-10MB per instance"
          },
          "suggestion": {
            "fix": "Clear interval/timeout in cleanup lifecycle (onUnmounted, useEffect return, etc.)",
            "example": "// React:\nuseEffect(() => {\n  const interval = setInterval(() => {...}, 1000)\n  return () => clearInterval(interval)\n}, [])",
            "docs": "https://github.com/productdevbook/ceviz#memory-leak-interval"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "setTimeout(resolve, 0);",
            "context": [
              "        setTimeout(resolve, 100);",
              "        requestAnimationFrame(() => {",
              "          setTimeout(resolve, 0);",
              "        });",
              "      });"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/dev-server-logs.js",
      "size": 1683,
      "lines": 61,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/debug-hooks.js",
      "size": 253,
      "lines": 10,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/cross-origin-prefetch.client.js",
      "size": 1123,
      "lines": 38,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/chunk-reload.client.js",
      "size": 945,
      "lines": 31,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/chunk-reload-immediate.client.js",
      "size": 801,
      "lines": 21,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/check-outdated-build.client.js",
      "size": 1184,
      "lines": 40,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/check-if-layout-used.js",
      "size": 872,
      "lines": 29,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/plugins/browser-devtools-timing.client.js",
      "size": 615,
      "lines": 24,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/url.js",
      "size": 247,
      "lines": 9,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/state.js",
      "size": 1434,
      "lines": 41,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "array-find-in-loop-33",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/state.js",
            "line": 33,
            "column": 64
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
            "context": [
              "  const nuxtApp = useNuxtApp();",
              "  const _allKeys = Object.keys(nuxtApp.payload.state).map((key) => key.substring(useStateKeyPrefix.length));",
              "  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
              "  for (const _key of _keys) {",
              "    const key = useStateKeyPrefix + _key;"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/ssr.js",
      "size": 3466,
      "lines": 114,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/script-stubs.js",
      "size": 3326,
      "lines": 105,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/runtime-hook.js",
      "size": 231,
      "lines": 8,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/router.js",
      "size": 7376,
      "lines": 198,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/route-announcer.js",
      "size": 1672,
      "lines": 56,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/ready.js",
      "size": 428,
      "lines": 16,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/preview.js",
      "size": 1969,
      "lines": 62,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/preload.js",
      "size": 1641,
      "lines": 56,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "array-find-in-loop-51",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/preload.js",
            "line": 51,
            "column": 37
          },
          "message": "Array.indexOf() inside loop creates O(n*m) complexity",
          "description": "Using indexOf() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.indexOf(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "}).finally(() => promises.splice(promises.indexOf(promise)));",
            "context": [
              "    }",
              "    const promise = Promise.resolve(component()).catch(() => {",
              "    }).finally(() => promises.splice(promises.indexOf(promise)));",
              "    promises.push(promise);",
              "  }"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/payload.js",
      "size": 5039,
      "lines": 138,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/payload.js",
            "line": 0,
            "column": 0
          },
          "message": "3 sequential await calls create waterfall",
          "description": "These 3 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "3x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/payload.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/payload.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/once.js",
      "size": 1123,
      "lines": 35,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/manifest.js",
      "size": 1940,
      "lines": 60,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/loading-indicator.js",
      "size": 3828,
      "lines": 143,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/lazy-hydration.js",
      "size": 69,
      "lines": 3,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/index.js",
      "size": 1551,
      "lines": 22,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/id.js",
      "size": 68,
      "lines": 3,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/hydrate.js",
      "size": 367,
      "lines": 15,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/head.js",
      "size": 136,
      "lines": 2,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/fetch.js",
      "size": 4027,
      "lines": 124,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "nested-loops-94",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/fetch.js",
            "line": 94,
            "column": 4
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const [key, value] of Object.entries(obj)) {",
            "context": [
              "    }",
              "    const unwrapped = {};",
              "    for (const [key, value] of Object.entries(obj)) {",
              "      unwrapped[toValue(key)] = toValue(value);",
              "    }"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/error.js",
      "size": 1285,
      "lines": 40,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/cookie.js",
      "size": 6775,
      "lines": 206,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/component.js",
      "size": 2767,
      "lines": 83,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/chunk.js",
      "size": 889,
      "lines": 31,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/asyncData.js",
      "size": 18747,
      "lines": 490,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "array-find-in-loop-272",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/asyncData.js",
            "line": 272,
            "column": 64
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
            "context": [
              "  const nuxtApp = useNuxtApp();",
              "  const _allKeys = Object.keys(nuxtApp.payload.data);",
              "  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);",
              "  for (const key of _keys) {",
              "    clearNuxtDataByKey(nuxtApp, key);"
            ]
          }
        },
        {
          "id": "array-find-in-loop-454",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/asyncData.js",
            "line": 454,
            "column": 15
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const list = signals.filter((s) => !!s);",
            "context": [
              "}",
              "function mergeAbortSignals(signals, timeout) {",
              "  const list = signals.filter((s) => !!s);",
              "  if (typeof timeout === \"number\" && timeout >= 0) {",
              "    const timeoutSignal = AbortSignal.timeout?.(timeout);"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/composables/asyncContext.js",
      "size": 287,
      "lines": 8,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/compat/vue-demi.js",
      "size": 112,
      "lines": 5,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/compat/interval.js",
      "size": 531,
      "lines": 12,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/compat/idle-callback.js",
      "size": 460,
      "lines": 16,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/compat/capi.js",
      "size": 398,
      "lines": 20,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/welcome.vue",
      "size": 25053,
      "lines": 35,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/welcome.d.vue.ts",
      "size": 529,
      "lines": 12,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/utils.js",
      "size": 4044,
      "lines": 127,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/test-component-wrapper.js",
      "size": 941,
      "lines": 28,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/server-placeholder.js",
      "size": 180,
      "lines": 8,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/route-provider.js",
      "size": 1558,
      "lines": 50,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-time.vue",
      "size": 5785,
      "lines": 149,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-time.d.vue.ts",
      "size": 1527,
      "lines": 38,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-teleport-island-slot.js",
      "size": 1626,
      "lines": 54,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-teleport-island-component.js",
      "size": 1304,
      "lines": 39,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-stubs.js",
      "size": 445,
      "lines": 15,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-route-announcer.js",
      "size": 1231,
      "lines": 49,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-root.vue",
      "size": 2827,
      "lines": 61,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-root.d.vue.ts",
      "size": 369,
      "lines": 4,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-loading-indicator.js",
      "size": 1922,
      "lines": 76,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-link.js",
      "size": 14249,
      "lines": 410,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-link.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-link.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-layout.js",
      "size": 5573,
      "lines": 172,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
      "size": 13164,
      "lines": 332,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "nested-loops-290",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
            "line": 290,
            "column": 37
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "{ default: () => (payloads.slots?.[slot]?.props?.length ? payloads.slots[slot].props : [{}]).map((data) => slots[slot]?.(data)) }",
            "context": [
              "                    // use different selectors for even and odd teleportKey to force trigger the teleport",
              "                    { to: import.meta.client ? `${isKeyOdd ? \"div\" : \"\"}[data-island-uid=\"${uid.value}\"][data-island-slot=\"${slot}\"]` : `uid=${uid.value};slot=${slot}` },",
              "                    { default: () => (payloads.slots?.[slot]?.props?.length ? payloads.slots[slot].props : [{}]).map((data) => slots[slot]?.(data)) }",
              "                  )",
              "                );"
            ]
          }
        },
        {
          "id": "nested-loops-301",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
            "line": 301,
            "column": 20
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const slot in slots2) {",
            "context": [
              "                    const { html: html2, slots: slots2 } = info;",
              "                    let replaced = html2.replaceAll(\"data-island-uid\", `data-island-uid=\"${uid.value}\"`);",
              "                    for (const slot in slots2) {",
              "                      replaced = replaced.replaceAll(`data-island-slot=\"${slot}\">`, (full) => full + slots2[slot]);",
              "                    }"
            ]
          }
        },
        {
          "id": "nested-loops-315",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
            "line": 315,
            "column": 70
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "return [h(component, props2, Object.fromEntries(Object.entries(slots2 || {}).map(([k, v]) => [",
            "context": [
              "                  const vnode = createVNode(Teleport, { to: `${isKeyOdd ? \"div\" : \"\"}[data-island-uid='${uid.value}'][data-island-component=\"${id2}\"]` }, {",
              "                    default: () => {",
              "                      return [h(component, props2, Object.fromEntries(Object.entries(slots2 || {}).map(([k, v]) => [",
              "                        k,",
              "                        () => createStaticVNode(`<div style=\"display: contents\" data-island-uid data-island-slot=\"${k}\">${v}</div>`, 1)"
            ]
          }
        },
        {
          "id": "array-find-in-loop-80",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
            "line": 80,
            "column": 74
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key2]) => !key2.startsWith(\"data-v-\"))) : {});",
            "context": [
              "    const config = useRuntimeConfig();",
              "    const nuxtApp = useNuxtApp();",
              "    const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key2]) => !key2.startsWith(\"data-v-\"))) : {});",
              "    const hashId = computed(() => hash([props.name, filteredProps.value, props.context, props.source]).replace(/[-_]/g, \"\"));",
              "    const instance = getCurrentInstance();"
            ]
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-island.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-error-page.vue",
      "size": 1209,
      "lines": 27,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-error-page.d.vue.ts",
      "size": 530,
      "lines": 10,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-error-boundary.vue",
      "size": 1029,
      "lines": 47,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/nuxt-error-boundary.d.vue.ts",
      "size": 877,
      "lines": 25,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/island-renderer.js",
      "size": 847,
      "lines": 29,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/injections.js",
      "size": 103,
      "lines": 3,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/index.js",
      "size": 49,
      "lines": 2,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/error-500.vue",
      "size": 4944,
      "lines": 47,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/error-500.d.vue.ts",
      "size": 712,
      "lines": 18,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/error-404.vue",
      "size": 5544,
      "lines": 49,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/error-404.d.vue.ts",
      "size": 714,
      "lines": 18,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/dev-only.js",
      "size": 311,
      "lines": 15,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/client-only.js",
      "size": 4410,
      "lines": 131,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/client-fallback.server.js",
      "size": 2293,
      "lines": 81,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "array-find-in-loop-54",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/client-fallback.server.js",
            "line": 54,
            "column": 26
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "await Promise.all(buffer.filter(isPromise));",
            "context": [
              "      const buffer = ssrVNodes.getBuffer();",
              "      if (buffer.hasAsync) {",
              "        await Promise.all(buffer.filter(isPromise));",
              "      }",
              "      return { ssrFailed, ssrVNodes };"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/app/components/client-fallback.client.js",
      "size": 1280,
      "lines": 51,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
      "size": 9511,
      "lines": 238,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "nested-loops-143",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
            "line": 143,
            "column": 10
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "for (const entry of toArray(componentMiddleware)) {",
            "context": [
              "            continue;",
              "          }",
              "          for (const entry of toArray(componentMiddleware)) {",
              "            middlewareEntries.add(entry);",
              "          }"
            ]
          }
        },
        {
          "id": "nested-loops-163",
          "rule": "nested-loops",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
            "line": 163,
            "column": 89
          },
          "message": "Nested loop detected (O(n²) complexity)",
          "description": "This code has 2 nested loops, resulting in O(n²) time complexity. For large datasets, this can cause severe performance issues.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n²)",
            "estimate": "100ms → 10s for 1000 items"
          },
          "suggestion": {
            "fix": "Use Map/Set for O(1) lookups instead of nested loops",
            "example": "// Instead of:\nfor (const user of users) {\n  for (const post of posts) {\n    if (post.userId === user.id) { ... }\n  }\n}\n\n// Use:\nconst postsByUser = new Map()\nfor (const post of posts) {\n  if (!postsByUser.has(post.userId)) {\n    postsByUser.set(post.userId, [])\n  }\n  postsByUser.get(post.userId).push(post)\n}\nfor (const user of users) {\n  const userPosts = postsByUser.get(user.id) || []\n  // ...\n}",
            "docs": "https://github.com/productdevbook/ceviz#nested-loops"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);",
            "context": [
              "          if (!middleware) {",
              "            if (import.meta.dev) {",
              "              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);",
              "            }",
              "            throw new Error(`Unknown route middleware: '${entry}'.`);"
            ]
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        },
        {
          "id": "sequential-requests-0",
          "rule": "sequential-requests",
          "severity": "warning",
          "category": "io",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/router.js",
            "line": 0,
            "column": 0
          },
          "message": "2 sequential await calls create waterfall",
          "description": "These 2 await statements run sequentially, but appear to be independent. Running them in parallel with Promise.all() would be faster.",
          "impact": {
            "type": "io",
            "level": "medium",
            "estimate": "2x slower than necessary"
          },
          "suggestion": {
            "fix": "Use Promise.all() to run these operations in parallel",
            "example": "// Instead of:\nconst data1 = await fetch('/api/1')\nconst data2 = await fetch('/api/2')\nconst data3 = await fetch('/api/3')\n\n// Use:\nconst [data1, data2, data3] = await Promise.all([\n  fetch('/api/1'),\n  fetch('/api/2'),\n  fetch('/api/3')\n])",
            "docs": "https://github.com/productdevbook/ceviz#sequential-requests"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "",
            "context": []
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/prerender.server.js",
      "size": 1827,
      "lines": 48,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "array-find-in-loop-35",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/prerender.server.js",
            "line": 35,
            "column": 8
          },
          "message": "Array.includes() inside loop creates O(n*m) complexity",
          "description": "Using includes() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.includes(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "if (route.path.includes(\":\")) {",
            "context": [
              "      routesToPrerender.add(currentPath);",
              "    }",
              "    if (route.path.includes(\":\")) {",
              "      continue;",
              "    }"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/prefetch.client.js",
      "size": 1326,
      "lines": 42,
      "complexity": "O(1)",
      "issues": [
        {
          "id": "array-find-in-loop-30",
          "rule": "array-find-in-loop",
          "severity": "critical",
          "category": "cpu",
          "location": {
            "file": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/prefetch.client.js",
            "line": 30,
            "column": 19
          },
          "message": "Array.filter() inside loop creates O(n*m) complexity",
          "description": "Using filter() inside a loop causes the array to be searched on every iteration, resulting in O(n*m) time complexity. This can be extremely slow for large datasets.",
          "impact": {
            "type": "cpu",
            "level": "high",
            "complexity": "O(n*m)",
            "estimate": "10ms → 5s for 1000x1000 items"
          },
          "suggestion": {
            "fix": "Convert array to Map/Set before the loop for O(1) lookups",
            "example": "// Instead of:\nfor (const item of items) {\n  const match = array.filter(x => x.id === item.id)\n}\n\n// Use:\nconst lookup = new Map(array.map(x => [x.id, x]))\nfor (const item of items) {\n  const match = lookup.get(item.id)\n}",
            "docs": "https://github.com/productdevbook/ceviz#array-find-in-loop"
          },
          "autoFixable": false,
          "codeSnippet": {
            "before": "middleware = middleware.filter((m) => typeof m === \"string\");",
            "context": [
              "      const layout = route.meta.layout;",
              "      let middleware = toArray(route.meta.middleware);",
              "      middleware = middleware.filter((m) => typeof m === \"string\");",
              "      for (const name of middleware) {",
              "        if (typeof namedMiddleware[name] === \"function\") {"
            ]
          }
        }
      ]
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/pages/runtime/plugins/check-if-page-unused.js",
      "size": 1013,
      "lines": 30,
      "complexity": "O(1)",
      "issues": []
    },
    {
      "path": "/Users/code/Work/example/ceviz/node_modules/nuxt/dist/head/runtime/plugins/unhead.js",
      "size": 1036,
      "lines": 32,
      "complexity": "O(1)",
      "issues": []
    }
  ],
  "timestamp": "2025-11-05T17:33:40.249Z",
  "duration": 115
}